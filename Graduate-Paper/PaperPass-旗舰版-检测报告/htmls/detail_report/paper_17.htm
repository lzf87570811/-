<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<title>PaperPass 最权威论文抄袭检测系统</title>
<style type="text/css">
<!--
user_icon {
color: #FFFFFF;
}
html
{
overflow-x:hidden;
overflow-y:auto;
}
body,td,th {
font-family: "微软雅黑";
font-size: 12px;
}
h1,h2,h3,h4,h5,h6 {
font-family: "宋体";
}
p{
margin-bottom:10px;
}
demo_padding {
line-height: 30px;
}
.zhengwen {
padding-right: 15px;
padding-left: 5px;
padding-bottom:100px;
font-size: 13px;
line-height: 20px;
color: #666666;
}
.zhengwencenter {
padding-right: 15px;
padding-left: 0px;
margin-bottom:10px;
font-size: 13px;
line-height: 20px;
color: #666666;
text-align:center
}
.neikuang {
background-color: #EBEBEB;
border: 1px solid #999999;
padding-right: 10px;
padding-left: 10px;
margin-top:10px;
margin-left:25px;
width:300px;
}
.shubu{
height: 20px;
width: 20px;
margin-left:25px;
background-color: #FFFFFF;
border: 1px solid #999999;
text-align: center;
vertical-align: middle;
display: block;
color: #666666;
}
a.red:link {color:#FF0000}
a.red:visited {color:#FF0000}
a.red:hover {color:#000000}
a.red:active {color:#000000}

a.orange:link {color:#FF6600}
a.orange:visited {color:#FF6600}
a.orange:hover {color:#000000}
a.orange:active {color:#000000}

a.dark:link {color:#666666}
a.dark:visited {color:#666666}
a.dark:hover {color:#000000}
a.dark:active {color:#000000}

a.pagelink:hover {color:#000000}
a.pagelink:active {color:#000000}

.green{color:#008000}
.gray{color:#666666}
.red{color:#FF0000}
.orange{color:#FF6600}
a{TEXT-DECORATION:none}

-->
</style>
</head>
<body>


<div class="zhengwen">
<div>
<span style="margin-left:25px"></span>
[
<a class="pagelink" href="paper_1.htm">首页</a>
<a class="pagelink" href="paper_16.htm">上一页</a>
<a class="pagelink" href="paper_18.htm">下一页</a>
<a class="pagelink" href="paper_18.htm">尾页</a>
页码：17/18页
]
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">886</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>//将读取的数据插入到Device</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">887</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>表中query.exec(QString(”update Typeset state = ’yes’ where id = ’%1’”).arg(sqlTmp));</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">888</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>//更新Type表中的一些类型的数据。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">889</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>因为数据处理相对复杂涉及到很多语句和query语句，这里就不一一介绍。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">890</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>5.5本章小结</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">891</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/1551/1551.htm' target='right' class='orange' >本章详细的分析介绍了手术器械管理系统的软件部分的设计。</a><span class='green'>第一节介绍了阅读器端MCU上的控制程序设计，介绍了整个MCU程序的大体结构和分析重要部分的代码实现过程；</span><span class='green'>第二节介绍了工控机端的基于 Qt技术的上位机程序开发过程，先从整体结构设计开始介绍，</span><span class='green'>再介绍了 Qt中本系统的 UI界面开发细节，然后结合流程图分析了一些重要环节的代码实现和原理。</span><a href='../sentence_detail/1555/1555.htm' target='right' class='orange' >第三节介绍了阅读器端的MCU和上位机之间的通信协议规范。</a><span class='green'>第四节单独介绍了本系统在上位机程序中涉及到的数据库知识和应用，使得读者更加清楚本系统对数据的处理方法。</span><span class='green'>总体上本章详细地分析了手术器械管理系统的软件设计过程和原理，使得读者能够很好的了解系统的软件部分。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">892</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/1558/1558.htm' target='right' class='orange' >第六章系统可靠性的研究与改进</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">893</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>手术器械管理系统从需求开始就是一个对安全可靠性要求很高的手术辅助器械，不允许系统的任何意外漏读出现（除人为操作失误外），否则后果不堪设想。</span><span class='green'>本系统在整体系统设计完成之后，根据理论分析和实际测量结果，对系统做了相应的可靠性分析和改进，确保系统的安全可靠。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">894</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>6.1系统的可靠性分析与改进</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">895</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>从系统的整体设计结构上来分析，可靠性需要得到保证的环节主要分为两个：</span><span class='green'>系统在读取RFID标签时的绝对无误和系统在数据传递时的完整无误。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">896</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>手术器械管理系统在登记录入天线和扫描天线读取数据时同时读取的标签数有限不会很多，</span><span class='green'>在目前的抗冲突读取中基本不会出现漏读的情况，即使这样本系统也做了防护措施，</span><span class='green'>采用多次读取的方法，防止任何一次遗漏读取。</span><span class='green'>在回收桶天线读取时难度比较大，因为手术器械用完后随手扔在桶中器械内嵌的 RFID标签朝向各个方向都有，</span><span class='green'>同时桶内的标签数也会比较多，这样的读取环境很容易造成遗漏，为此专门设计了读取算法来避免漏读。</span><span class='green'>数据通信发生在RFID标签到系统的阅读器和阅读器到上位机程序，只要任何一个环节出了问题，数据都会出现错误，是一种串联的关系，一断则断。</span><a href='../sentence_detail/1570/1570.htm' target='right' class='orange' >因此在通信中都采用CRC校验的方法，来确保每次通信数据的正确性。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">897</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>6.2系统在数据通信上的可靠性保障</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">898</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>在以前的通信应用中，由于技术的限制，和通信中信道的复杂多变，严重干扰了信号在信道里的传输，很容易就出现误码，导致信息的不可靠。</span><a href='../sentence_detail/1573/1573.htm' target='right' class='orange' >为了保证数据通信上的可靠性，就需要通过校验数据来判别信息的正确性。</a><a href='../sentence_detail/1574/1574.htm' target='right' class='orange' >循环冗余校验就是目前串口通信中最常用的方法。</a><span class='green'>它从通信中信息的本身来校验，采用数学的运算办法对信息进行分析处理。</span><span class='green'>如果运算后结果正确就保留，如果运算结果不正确就丢弃或者修复该信息。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">899</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>循环冗余校验，先将数据转化为多项式，然后对多项式进行计算，将得到的结果附加在信息之后。</span><a href='../sentence_detail/1578/1578.htm' target='right' class='orange' >接收到该信息的设备，采用同样的CRC校验，从而确保接收信息的完整性和无误性。</a><span class='green'>CRC信息码有信息码（n个比特）和校验码（k个比特）组成，写成（n，k）码。</span><a href='../sentence_detail/1580/1580.htm' target='right' class='orange' >编码规则是先将信息码左移r位，再对生产多项式模二除，计算得到的余数就是CRC的校验码。</a><a href='../sentence_detail/1581/1581.htm' target='right' class='orange' >对于任意通信码字，有且仅有一个R次多项式g（x），其计算的数学表达式如式子6-1：</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">900</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>(6-1)</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">901</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/1583/1583.htm' target='right' class='orange' >其中m(x)是信息多项式，r(x)是校验多项式，g(x)是生成多项式如式子6-2：</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">902</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>(6-2)</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">903</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/1585/1585.htm' target='right' class='orange' >信源通过生成多项式产生CRC校验码，信宿则利用生成多项式来验证接收的信息。</a><span class='green'>循环冗余校验根据权的不同，其生成多项式有CRC8、CRC12、CRC16、CRC32等。</span><span class='green'>本项目采用的是CRC16其生成多项式如式子6-3：</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">904</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>(6-3)</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">905</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/1589/1589.htm' target='right' class='orange' >下面详细分析任意长度数据流的CRC16校验码生成的过程。</a><span class='green'>智能纱布系统所采集的数据流被分成若干个8bit字符，并且是从低字节到高字节发送方式来计算CRC 校验码。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">906</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>图6-1CRC校验图</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">907</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>具体生成校验码的过程是，用一个十六位的寄存器来存放信息码字，寄存器的初值是0x0000；</span><a href='../sentence_detail/1593/1593.htm' target='right' class='orange' >先将信息的低位八比特和寄存器的高八位相异或，结果就保存在寄存器的高八位中；</a><span class='green'>然后寄存器左移一位。</span><a href='../sentence_detail/1595/1595.htm' target='right' class='orange' >左移后低位补零，如果移出的高位是零，就继续左移，直到移出为是一；</a><a href='../sentence_detail/1596/1596.htm' target='right' class='orange' >之后把生成多项式和寄存器异或，结果还是保存在寄存器中；</a><span class='green'>重复上述过程直到处理完成十六位数据。</span><a href='../sentence_detail/1598/1598.htm' target='right' class='orange' >完成上面的计算后，寄存器中的数据就是该信息码的CRC校验码。</a><span class='green'>上图6-1展示了CRC计算流程。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">908</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>在手术器械管理系统的上位机中，串口接收的每一帧数据都将经过 calc_ crc()函数校验，该函数需要两个参数，</span><span class='green'>这两个参数正是上一章节串口程序中讲到的 newDataInPortSignal( data， readcount)信号发射后传递的两个参数；</span><span class='green'>第一个参数用来指示等待校验数据的长度，第二个参数是一个指向存储等待校验数据的首地址，其实现代码如下：</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">909</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>int calc_crc(unsigned int byte_len， unsigned int *data_byte)</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">910</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>{unsigned int current_crc_value;</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">911</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>unsigned int i，j;</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">912</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>current_crc_value=0xFFFF;</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">913</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>for(i=0;</span><span class='green'>i[byte_len;</span><span class='green'>i++)</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">914</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>{current_crc_value=current_crc_value^data_byte[i];</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">915</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>for(j=0;</span><span class='green'>j[8;</span><span class='green'>j++)</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">916</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>{if(current_crc_value 0x0001)</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">917</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>{current_crc_value=(current_crc_value]]1)^0x8408;</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">918</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>else{</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">919</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>current_crc_value=(current_crc_value]]1);</span><span class='green'>}}</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">920</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>current_crc_value = ~current_crc_value;</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">921</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>return(current_crc_value 0xFFFF);</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">922</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>只有在经过CRC校验后，并且结果正确，程序才将该帧数据接着传入到下一层，就是上面提到的环形缓冲层。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">923</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/1622/1622.htm' target='right' class='orange' >在MCU程序中采用字节查表法来进行CRC校验，在MCU硬件端可以大大提高计算速度。</a><span class='green'>程序如下：</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">924</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>u16 table_crc(u8 *ptr，u16 len) // 字节查表法求 CRC</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">925</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>u16 crc=0xffff;</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">926</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>while(len--)</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">927</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>crc= (crc ]] 8) ^ crc_ta((crc ^ *ptr) 0xff);</span><span class='green'>//FLASH</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">928</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>ptr ++;</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">929</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>return(~crc);</span><span class='green'>// CRC校验码取反</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">930</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>crc_ta是先前算好的CRC16的256个余式表数组，存放在flash内存中。</span><span class='green'>通过uint table_crc(uchar *ptr，uchar len)函数来快速计算CRC，输入:</span><span class='green'>uchar *ptr:</span><span class='green'>数据；</span><span class='green'>uchar len :</span><span class='green'>数据长度。</span><span class='green'>输出:</span><span class='green'>CRC16码。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">931</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>通过以上2次的CRC校验，确保了在数据传递的环节中不会出现错误数据，杜绝了因数据传递出错了而引起的问题，做到有传递就有校验。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">932</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>6.3系统在数据读取上的可靠性保障</span>
</p>
</div>


<div>
<span style="margin-left:25px"></span>
[
<a class="pagelink" href="paper_1.htm">首页</a>
<a class="pagelink" href="paper_16.htm">上一页</a>
<a class="pagelink" href="paper_18.htm">下一页</a>
<a class="pagelink" href="paper_18.htm">尾页</a>
页码：17/18页
]
</div>

<br>
<div style="margin-left:8px">

<div style="text-align:center;background-color:#CA122C;margin-top:30px;overflow:hidden;">
<a href="http://www.paperpass.com/publish/index?from=ppreport_banner" target="_blank" style="display:block;"><img height="180" src="http://file.paperpass.com/images/fabiao.jpg"></a>
</div>

</div>
</div>


<div class="zhengwencenter">
<p>
检测报告由<a href="http://www.paperpass.com/" target="_blank">PaperPass</a>文献相似度检测系统生成
</p>
<p>
Copyright © 2007-2017 PaperPass
</p>
</div>
<div style="margin-bottom:400px"></div>
</body>
</html>
