<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<title>PaperPass 最权威论文抄袭检测系统</title>
<style type="text/css">
<!--
user_icon {
color: #FFFFFF;
}
html
{
overflow-x:hidden;
overflow-y:auto;
}
body,td,th {
font-family: "微软雅黑";
font-size: 12px;
}
h1,h2,h3,h4,h5,h6 {
font-family: "宋体";
}
p{
margin-bottom:10px;
}
demo_padding {
line-height: 30px;
}
.zhengwen {
padding-right: 15px;
padding-left: 5px;
padding-bottom:100px;
font-size: 13px;
line-height: 20px;
color: #666666;
}
.zhengwencenter {
padding-right: 15px;
padding-left: 0px;
margin-bottom:10px;
font-size: 13px;
line-height: 20px;
color: #666666;
text-align:center
}
.neikuang {
background-color: #EBEBEB;
border: 1px solid #999999;
padding-right: 10px;
padding-left: 10px;
margin-top:10px;
margin-left:25px;
width:300px;
}
.shubu{
height: 20px;
width: 20px;
margin-left:25px;
background-color: #FFFFFF;
border: 1px solid #999999;
text-align: center;
vertical-align: middle;
display: block;
color: #666666;
}
a.red:link {color:#FF0000}
a.red:visited {color:#FF0000}
a.red:hover {color:#000000}
a.red:active {color:#000000}

a.orange:link {color:#FF6600}
a.orange:visited {color:#FF6600}
a.orange:hover {color:#000000}
a.orange:active {color:#000000}

a.dark:link {color:#666666}
a.dark:visited {color:#666666}
a.dark:hover {color:#000000}
a.dark:active {color:#000000}

a.pagelink:hover {color:#000000}
a.pagelink:active {color:#000000}

.green{color:#008000}
.gray{color:#666666}
.red{color:#FF0000}
.orange{color:#FF6600}
a{TEXT-DECORATION:none}

-->
</style>
</head>
<body>


<div class="zhengwen">
<div>
<span style="margin-left:25px"></span>
[
<a class="pagelink" href="paper_1.htm">首页</a>
<a class="pagelink" href="paper_13.htm">上一页</a>
<a class="pagelink" href="paper_15.htm">下一页</a>
<a class="pagelink" href="paper_18.htm">尾页</a>
页码：14/18页
]
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">729</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>redata=0;</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">730</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>redata=redata]]1;</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">731</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>5.1.4 标签抗冲突代码实现</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">732</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>抗冲突是ISO15693协议标签的重要功能，及能同时读取场内多张射频标签的特性。</span><span class='green'>其实现的原理是在标签端和阅读器端都进行特殊处理，本小节将着重介绍阅读器端的抗冲突实现过程。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">733</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>ISO15693协议中介绍的16slot的抗冲突如图5-2所示的步骤如下：</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">734</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/1260/1260.htm' target='right' class='red' >VCD发送一次目录请求，在一帧内，由 EOF结束。</a><span class='green'>slots的数量是16。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">735</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>VICC 1在 slot 0发送其响应。</span><a href='../sentence_detail/1263/1263.htm' target='right' class='red' >它是唯一发送响应的 VICC，因此不会发生冲突，VCD收到它的UID并为其注册。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">736</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>VCD发送一个 EOF，意思是接通到下一 slot。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">737</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>在 slot 1，两个 VICCs 2和 3同时传输它们的响应，产生一次冲突。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">738</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>VCD发送一个 EOF，意思是接通至下一个 slot。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">739</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>在 slot 2，没有 VICC传输响应。</span><a href='../sentence_detail/1268/1268.htm' target='right' class='red' >因此 VCD不检测一个 VICC SOF，而是通过发送一个 EOF，接通至下一个 slot。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">740</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/1269/1269.htm' target='right' class='red' >VCD决定发送一个寻址请求（例如一个读块请求）给 VICC 1，其 UID已被正确接收。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">741</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>所有的 VICCs检测到 SOF，将退出防冲突序列。</span><a href='../sentence_detail/1271/1271.htm' target='right' class='red' >它们处理这个请求，因为请求地址是配给 VICC1的，只有 VICC 1可传输其响应。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">742</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>注：</span><span class='green'>中断防冲突序列的决定权在 VCD。</span><span class='green'>它可以持续发送 EOF，直到遍历至 slot 15，然后发送请求给 VICC 1。</span><span class='green'>其中VICC：</span><span class='green'>标签，VCD：</span><span class='green'>阅读器。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">743</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>图5-2 ISO15693协议中16slot的抗冲突步骤</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">744</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>根据协议的定义和实际的手术器械管理系统的情况设计了一套简化的但效率高的抗冲突实现方法。</span><span class='green'>结合协议中的抗冲突方法，第一步从 slot0开始发送 Mask值为0 x00（因不足8位补齐8位），</span><span class='green'>Mask长度为4，如果没有产生冲突（如果有返回接收返回的标签 UID），并发送 EOF接通到下一个 slot（ Mask值为0 x01，</span><span class='green'>Mask长度为4），这样一直下去，直到0 x0 F结束整个抗冲突过程。</span><span class='green'>这个过程中一旦产生冲突在此时Mask值变为0x0Y（Y为产生冲突的slot，Y值：</span><span class='green'>0-15）， Mask长度变为8，及在原来的基础上加长4位进行比较，如果还产生冲突在往上加4位，</span><span class='green'>Mask值为0 x000 Y， Mask值为12，直到没有冲突产生，但最高 Mask长度可以加到16位（考虑到抗冲突过程的时间）。</span><span class='green'>这种抗冲突的方式因为减省了与标签的一部分通信，可以在标签不是很多的情况快速读取（因为手术器械管理系统要求一次读取的标签数在50张左右），</span><a href='../sentence_detail/1287/1287.htm' target='right' class='orange' >这样可以大大提高抗冲突的效率，从而提高了对标签的识别效率。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">745</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>5.2上位机软件设计</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">746</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>上位机程序是整个系统的开始点和结束点，是系统与人的交互点，因此界面不仅要简洁明了，更要保证操作快捷方便。</span><span class='green'>利用Qt特有的信号与槽的机制使得系统操作者只需点击界面按钮，便可触发对应的操作，完成数据的获取。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">747</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>5.2.1 Qt技术简介</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">748</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/1292/1292.htm' target='right' class='red' >Qt是一个跨平台应用程序和UI开发框架。</a><a href='../sentence_detail/1293/1293.htm' target='right' class='red' >使用Qt只须一次性开发应用程序，无须重新编写源代码，便可跨不同桌面部署这些应用程序。</a><a href='../sentence_detail/1294/1294.htm' target='right' class='red' >Qt Software的前身为创始于1994年的Trolltech（奇趣科技），Trolltech于2008年6月被Nokia收购，加速了其跨平台开放战略。</a><a href='../sentence_detail/1295/1295.htm' target='right' class='red' >Qt Creator是支持Qt跨平台开发的Qt IDE，可单独使用，也可以与Qt库和开发工具组成一套的完整的SDK。</a><span class='green'>其中包括：</span><a href='../sentence_detail/1297/1297.htm' target='right' class='red' >高级C++代码编写器、项目和生成管理工具、集成的上下文相关的帮助系统、图形调试器、代码管理和浏览工具。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">749</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>Qt Creator 具有两个很方便开发的特点：</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">750</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>Qt中UI开发可以直接通过拖拽现有的部件库元件置对应的开发界面上，在通过简单的布局设计就可以快速完成一个美观，快捷的UI界面开发。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">751</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/1300/1300.htm' target='right' class='orange' >信号与槽的机制，可以完成对象之间的协同操作。</a><span class='green'>简单的说，信号与槽都是函数，比如单机窗口上的一个按钮想要弹出一个对话框，那么就可以将这个按钮的单击 click（）信号与定义的槽函数关联起来，</span><span class='green'>当点击这个按钮时发出 click（）信号，当前界面检测到该按钮的 click（）信号后就会自动调用定义的槽函数来创建一个对话框。</span><span class='green'>这种机制可以快速、方便的将界面的操作和后台执行程序绑定，实现相应的功能。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">752</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>5.2.2上位机软件框架设计</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">753</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>整个上位机的业务需求：</span><span class='green'>手术开始打开手术管理系统，点击操作界面的登记录入（ COUNT IN）按钮，将手术器械使用前在登记录入处扫描录入，</span><span class='green'>器械使用完后扔进回收桶中。</span><span class='green'>手术结束后点击回收（COUNT OUT）按钮，系统自动统计回收桶中的器械。</span><span class='green'>根据显示结果判断，如果有未回收的遗漏器械，且不在可视范围内，点击扫描（SCAN）按钮用扫描器去病人身体部位探测寻找，快速定位遗漏器械的位置。</span><span class='green'>最后点击详情（DETAIIED）按钮进入详细数据界面保存数据，以便日后查询手术记录查看手术器械使用情况。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">754</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/1311/1311.htm' target='right' class='orange' >根据业务需求整个系统的上位机程序框架设计如下图5-3所示：</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">755</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>图5-3上位机程序框架图</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">756</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>5.2.3上位机操作界面的设计</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">757</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>用户UI模块就是系统数据显示与用户交互的界面，采用Qt自带的控件进行拖拽式布局设计，快速完成交互界面的开发。</span><span class='green'>其中用户的点击按钮采用Qt的button控件结合信号与槽的机制，实现按钮点击后的后台程序触发。</span><span class='green'>系统数据显示采用TableView控件，结合它的视图模型可以简单快速的显示数据库表的数据。</span><span class='green'>UI界面设计图如图5-4所示。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">758</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>图5-4 UI界面设计图</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">759</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>上图中控件通过QLayout类提供的布局管理器，进行了整理布局，使得界面更加整洁美观，界面按水平布局为主，大体分成了三部分。</span><span class='green'>具体如图5-5所示：</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">760</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>图5-5 UI界面分布图</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">761</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>5.2.4后台控制程序的实现</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">762</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>后台控制程序主要分成两个部分：</span><span class='green'>串口通信程序和数据处理程序。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">763</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>串口通信程序主要功能是负责与系统的阅读器通信，发送指令到阅读器，并接收阅读器返回的数据。</span><a href='../sentence_detail/1326/1326.htm' target='right' class='orange' >由于系统要确保所接收阅读器数据的安全性和实时性；</a><span class='green'>在安全性方面，采用CRC16校验确保每一帧数据的正确传输（次部分将在下一章节着重介绍）；</span><a href='../sentence_detail/1328/1328.htm' target='right' class='orange' >在实时性方面，采用经典的生产者消费者模型的多线程机制确保串口数据的实时处理。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">764</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/1329/1329.htm' target='right' class='orange' >Qt没有现成的串口通信类库调用，借助第三方的串口通信类qextserialport实现，该类分为Win_QextSerialPort和Posix_QextSerialPort分别支持Windows和Linux两种环境。</a><span class='green'>在项目管理文件.Pro文件中进行如下配置：</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">765</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>unix:</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">766</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>DEFINES = _TTY_POSIX_</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">767</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>HEADERS += qextserialport/posix_qextserialport.h</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">768</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>SOURCES += qextserialport/posix_qextserialport.cpp</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">769</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>win32 {</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">770</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>DEFINES = _TTY_WIN_</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">771</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>HEADERS += qextserialport/win_qextserialport.h</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">772</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>SOURCES += qextserialport/win_qextserialport.cpp</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">773</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>然后在 Qt框架下实现串口发送部分比较简单，先获取待发送的字符串，即要发送命名码子，</span><span class='green'>然后采用 HexStrToByteArray( QString str)函数将字符串转换成十六进制码子，再调用 write()函数将转换后的十六进制码子发送出去，</span><a href='../sentence_detail/1341/1341.htm' target='right' class='orange' >将字符串转换成十六进制码子的 HexStrToByteArray( QString str)函数代码如下：</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">774</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>QByteArray HexStrToByteArray(QString str)//字符转十六进制后经串口发送</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">775</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>QByteArray senddata;</span><span class='green'>//字符转十六进制后暂存在senddata变量中</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">776</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>bool ok;</span><span class='green'>char data;</span><span class='green'>QStringList list;</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">777</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>list = str.split(” ”);</span><span class='green'>//将待转换的字符以空格划分开</span>
</p>
</div>


<div>
<span style="margin-left:25px"></span>
[
<a class="pagelink" href="paper_1.htm">首页</a>
<a class="pagelink" href="paper_13.htm">上一页</a>
<a class="pagelink" href="paper_15.htm">下一页</a>
<a class="pagelink" href="paper_18.htm">尾页</a>
页码：14/18页
]
</div>

<br>
<div style="margin-left:8px">

<div style="text-align:center;background-color:#CA122C;margin-top:30px;overflow:hidden;">
<a href="http://www.paperpass.com/publish/index?from=ppreport_banner" target="_blank" style="display:block;"><img height="180" src="http://file.paperpass.com/images/fabiao.jpg"></a>
</div>

</div>
</div>


<div class="zhengwencenter">
<p>
检测报告由<a href="http://www.paperpass.com/" target="_blank">PaperPass</a>文献相似度检测系统生成
</p>
<p>
Copyright © 2007-2017 PaperPass
</p>
</div>
<div style="margin-bottom:400px"></div>
</body>
</html>
