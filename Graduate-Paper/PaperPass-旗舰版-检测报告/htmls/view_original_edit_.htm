<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<title>PaperPass 最权威论文抄袭检测系统</title>
<style type="text/css">
<!--
user_icon {
color: #FFFFFF;
}
html
{
overflow-x:hidden;
overflow-y:auto;
}
body,td,th {
font-family: "微软雅黑";
font-size: 12px;
}
h1,h2,h3,h4,h5,h6 {
font-family: "宋体";
}
p{
margin-bottom:10px;
}
demo_padding {
line-height: 30px;
}
.zhengwen {
padding-right: 15px;
padding-left: 5px;
padding-bottom:100px;
font-size: 13px;
line-height: 20px;
color: #666666;
}
.zhengwencenter {
padding-right: 15px;
padding-left: 0px;
margin-bottom:10px;
font-size: 13px;
line-height: 20px;
color: #666666;
text-align:center
}
.neikuang {
background-color: #EBEBEB;
border: 1px solid #999999;
padding-right: 10px;
padding-left: 10px;
margin-top:10px;
margin-left:25px;
width:300px;
}
.shubu{
height: 20px;
width: 20px;
margin-left:25px;
background-color: #FFFFFF;
border: 1px solid #999999;
text-align: center;
vertical-align: middle;
display: block;
color: #666666;
}
a.red:link {color:#FF0000}
a.red:visited {color:#FF0000}
a.red:hover {color:#000000}
a.red:active {color:#000000}

a.orange:link {color:#FF6600}
a.orange:visited {color:#FF6600}
a.orange:hover {color:#000000}
a.orange:active {color:#000000}

a.dark:link {color:#666666}
a.dark:visited {color:#666666}
a.dark:hover {color:#000000}
a.dark:active {color:#000000}

a.pagelink:hover {color:#000000}
a.pagelink:active {color:#000000}

.green{color:#008000}
.gray{color:#666666}
.red{color:#FF0000}
.orange{color:#FF6600}
a{TEXT-DECORATION:none}

-->
</style>
</head>
<body>


<div class="zhengwen">

<span style="margin-left:25px"></span><font size=3 color=red>蓝色文字是系统自动修改的结果，仅供参考，如需使用请加工润色！</font><br><br><span style="margin-left:25px"></span>摘要IIIAbstractiv
<br><br>
<span style="margin-left:25px"></span>第一章绪论6
<br><br>
<span style="margin-left:25px"></span>1.1课题来源6
<br><br>
<span style="margin-left:25px"></span>1.2课题研究的目的和意义6
<br><br>
<span style="margin-left:25px"></span>1.3 国内外研究概况2
<br><br>
<span style="margin-left:25px"></span>1.3.1 国外对手术器械管理系统的研究2
<br><br>
<span style="margin-left:25px"></span>1.3.2 国内对手术器械管理系统的研究3
<br><br>
<span style="margin-left:25px"></span>1.4 论文的主要研究内容4
<br><br>
<span style="margin-left:25px"></span>第二章 RFID射频技术原理6
<br><br>
<span style="margin-left:25px"></span>2.1 RFID原理简介6
<br><br>
<span style="margin-left:25px"></span>2.2 RFID应用介绍10
<br><br>
<span style="margin-left:25px"></span>2.3 ISO15693标签11
<br><br>
<span style="margin-left:25px"></span>2.3.1 ISO15693标签的协议分析11
<br><br>
<span style="margin-left:25px"></span>2.3.2 ISO15693标签常用的命令集15
<br><br>
<span style="margin-left:25px"></span>2.3.3 ISO15693标签特点分析16
<br><br>
<span style="margin-left:25px"></span>2.3本章小结17
<br><br>
<span style="margin-left:25px"></span>第三章手术器械管理系统架构原理分析与设计18
<br><br>
<span style="margin-left:25px"></span>3.1 系统整体结构规划设计18
<br><br>
<span style="margin-left:25px"></span>3.1.1 手术器械管理系统的需求分析18
<br><br>
<span style="margin-left:25px"></span>3.1.2 手术器械管理系统系统框图19
<br><br>
<span style="margin-left:25px"></span>3.1.3 手术器械管理系统的实现方案20
<br><br>
<span style="margin-left:25px"></span>3.2 RFID标签选型以及系统相关要求参数说明21
<br><br>
<span style="margin-left:25px"></span>3.2.1 手术器械管理系统的相关参数要求21
<br><br>
<span style="margin-left:25px"></span>3.2.1 手术器械管理系统的RFID标签选型21
<br><br>
<span style="margin-left:25px"></span>3.3天线分布与设计概述22
<br><br>
<span style="margin-left:25px"></span>3.3.1手术器械管理系统天线设计的基本要求22
<br><br>
<span style="margin-left:25px"></span>3.3.2系统天线的结构22
<br><br>
<span style="margin-left:25px"></span>3.3.3 天线尺寸的理论分析23
<br><br>
<span style="margin-left:25px"></span>3.3.4 天线具体分布和形状25
<br><br>
<span style="margin-left:25px"></span>3.4工控机概述与应用介绍26
<br><br>
<span style="margin-left:25px"></span>3.4.1 工控机的概念26
<br><br>
<span style="margin-left:25px"></span>3.4.2 工控机的特点27
<br><br>
<span style="margin-left:25px"></span>3.4.3 工控机的应用28
<br><br>
<span style="margin-left:25px"></span>3.5本章小结28
<br><br>
<span style="margin-left:25px"></span>第四章系统硬件部分30
<br><br>
<span style="margin-left:25px"></span>4.1 射频前端电路设计30
<br><br>
<span style="margin-left:25px"></span>4.1.1 发射电路设计30
<br><br>
<span style="margin-left:25px"></span>4.1.2 接收电路设计31
<br><br>
<span style="margin-left:25px"></span>4.2 FPGA编解码电路设计31
<br><br>
<span style="margin-left:25px"></span>4.2.1 FPGA原理简述31
<br><br>
<span style="margin-left:25px"></span>4.2.2 编解码电路的Verilog设计33
<br><br>
<span style="margin-left:25px"></span>4.2.3 编解码电路的软件仿真37
<br><br>
<span style="margin-left:25px"></span>4.3 MCU逻辑控制电路设计38
<br><br>
<span style="margin-left:25px"></span>4.3.1 MCU原理简述与系统MCU芯片选型38
<br><br>
<span style="margin-left:25px"></span>4.3.2 MCU电路设计41
<br><br>
<span style="margin-left:25px"></span>4.3.3 MCU外围电路设计42
<br><br>
<span style="margin-left:25px"></span>4.4 MCU与FPGA编解码电路接口设计43
<br><br>
<span style="margin-left:25px"></span>4.5本章小结44
<br><br>
<span style="margin-left:25px"></span>第五章系统软件部分45
<br><br>
<span style="margin-left:25px"></span>5.1MCU软件设计45
<br><br>
<span style="margin-left:25px"></span>5.1.1 STC单片机软件开发介绍45
<br><br>
<span style="margin-left:25px"></span>5.1.2 MCU软件框架设计47
<br><br>
<span style="margin-left:25px"></span>5.1.3 MCU核心代码的实现47
<br><br>
<span style="margin-left:25px"></span>5.1.4 标签抗冲突代码实现52
<br><br>
<span style="margin-left:25px"></span>5.2上位机软件设计53
<br><br>
<span style="margin-left:25px"></span>5.2.1 Qt技术简介53
<br><br>
<span style="margin-left:25px"></span>5.2.2上位机软件框架设计54
<br><br>
<span style="margin-left:25px"></span>5.2.3上位机操作界面的设计55
<br><br>
<span style="margin-left:25px"></span>5.2.4后台控制程序的实现56
<br><br>
<span style="margin-left:25px"></span>5.3上位机与MCU的通信协议设计60
<br><br>
<span style="margin-left:25px"></span>5.4数据库的设计61
<br><br>
<span style="margin-left:25px"></span>5.4.1数据库相关技术简介61
<br><br>
<span style="margin-left:25px"></span>5.4.2数据库结构设计62
<br><br>
<span style="margin-left:25px"></span>5.4.3系统中有关数据库程序63
<br><br>
<span style="margin-left:25px"></span>5.5本章小结64
<br><br>
<span style="margin-left:25px"></span>第六章系统可靠性的研究与改进64
<br><br>
<span style="margin-left:25px"></span>6.1系统的可靠性分析与改进65
<br><br>
<span style="margin-left:25px"></span>6.2系统在数据通信上的可靠性保障65
<br><br>
<span style="margin-left:25px"></span>6.3系统在数据读取上的可靠性保障67
<br><br>
<span style="margin-left:25px"></span>6.4系统的实物和运行界面展示69
<br><br>
<span style="margin-left:25px"></span>6.5 本章小结70
<br><br>
<span style="margin-left:25px"></span>第七章结论与展望71
<br><br>
<span style="margin-left:25px"></span>7.1结论71
<br><br>
<span style="margin-left:25px"></span>7.2展望72
<br><br>
<span style="margin-left:25px"></span>参考文献74
<br><br>
<span style="margin-left:25px"></span>英文缩写词表76
<br><br>
<span style="margin-left:25px"></span>作者在攻读硕士学位期间公开发表的论文及参加的项目77
<br><br>
<span style="margin-left:25px"></span>A：
<br><br>
<span style="margin-left:25px"></span>在国内外刊物录用的论文77B：
<br><br>
<span style="margin-left:25px"></span>参加的项目77致 谢78
<br><br>
<span style="margin-left:25px"></span>基于ISO15693芯片的RFID手术器械管理系统的研制
<br><br>
<span style="margin-left:25px"></span>研究生：
<br><br>
<span style="margin-left:25px"></span>陆志峰 学科专业：通信与信息系统（RFID技术应用）指导教师：
<br><br>
<span style="margin-left:25px"></span>景为平研究员摘要
<br><br>
<span style="margin-left:25px"></span>随着智能化、网络化生产生活的普及和生活质量的提高，促使人们对医疗设备提出更高更智能化的要求，
<br><br>
<span style="margin-left:25px"></span>促使了高新技术在医疗设备制造行业的普及，一方面提高了医疗设备的智能化水平；另一方面也增加了医疗设备的复杂性，对其安全性和可靠性提出了更高的要求。尤其是在手术过程中，规范的管理和使用手术器械，不仅是保障医师正常进行手术的基础，也是保证病人生命安全的必要条件，更是给手术中器械管理人员以及器械管理软件系统提出了越来越高的要求。根据一些调查和研究结果显示，在手术中手术异物遗留导致手术失败的比例占绝大多数。
<br><br>
<span style="margin-left:25px"></span>特别是在高难度的手术中，由于参与手术的医疗人员比较多，使用的手术器材同样是多种多样，并且手术过程高度紧张，手术时间相当紧迫，争分夺秒；另外由于纱布和某些手术器械完全浸没与血肉间，给肉眼识别带来极大的困难。即便是在有多名医疗器械管理人员，对手术器械进行清点的情况下，发生手术器械残留在病人体内的案列也是屡见不鲜。因此给病人的健康，乃至生命带来极大的威胁。本文针对RSIS的难题，提出了基于ISO15693射频标签的射频识别(RFID)手术器械管理系统。
<br><br>
<span style="margin-left:25px"></span>将ISO15693射频标签内置在手术器械中，采用三通道天线协调工作的RFID阅读器完成对手术器械的登记录入、回收统计和寻找扫描。借助Qt图形界面应用程序开发框架，实现对手术器械管理系统的上位机操作界面的设计。实验表明系统能够稳定、快速、准确地实现对手术器械使用和回收的智能化管理，有效地防止了手术器械遗留问题的发生，给手术安全提供了更加高效可靠的保障。关键词：
<br><br>
<span style="margin-left:25px"></span>RFID；RSIS；ISO15693射频标签；手术器械；Qt第一章绪论
<br><br>
<span style="margin-left:25px"></span>1.1课题来源
<br><br>
<span style="margin-left:25px"></span>本课题来源于低功耗射频识别标签芯片研制，江苏省科技支撑计划-工业部分（重点），项目编号BE2013008-3。
<br><br>
<span style="margin-left:25px"></span>1.2课题研究的目的和意义
<br><br>
<span style="margin-left:25px"></span>根据一些调查和研究结果显示，在手术中异物遗留导致手术失败的比例占绝大多数。
<br><br>
<span style="margin-left:25px"></span>特别是在高难度的手术中，由于参与手术的医疗人员比较多，使用的手术器材同样是多种多样，并且手术过程高度紧张，手术时间相当紧迫，争分夺秒；另外由于纱布和某些手术器械完全浸没与血肉间，给肉眼识别这些纱布带来极大的困难。即便是在有多名医疗器械管理人员，对手术器械进行清点的情况下，发生手术器械残留在病人体内的案列，也是屡见不鲜。因此给病人的健康，乃至生命带来极大的威胁。2012年9月《纽约时报》报道了一位女士因手术异物遗留造成严重伤害的案例。
<br><br>
<span style="margin-left:25px"></span>数据显示，从2005年至2016年，联合委员会警讯事件数据库共收到772例手术异物遗留事件报告，其中造成16人直接死亡。这表明手术异物遗留给患者不仅带来了不必要的伤害和疼痛的折磨，甚至直接威胁到他的生命安全。在医患关系如此紧张的今天，手术异物遗留问题必须引起我们的重视。要解决手术异物遗留的问题，就在于对手术中手术器械的使用和回收进行科学、严格管理，杜绝任何手术器械遗漏的情况发生。通过调研发现，目前在国内的医院手术中，为防止手术器械（如纱布、手术剪刀、血管钳等）遗留在病人体内，采用严格的三人四次清点制度，完全依赖人工清点与回收，这不仅增加了手术的复杂度和管理成本，而且不能对手术中使用的所有器械进行统一规范的管理统计。面对这样的困境和难题，发挥 RFID技术的优势，并对手术器械的使用和回收做校验的设计理念，
<br><br>
<span style="margin-left:25px"></span>在手术器械中运用 RFID技术来识别、追踪和定位手术器械可以大大减少意外的发生，确保手术器械完全回收无遗漏，使得器械管理员的工作更简单和安全。这不仅可以重整医疗保险事业的信心，也给病人的人身安全提供了一道有力的保障。1.3 国内外研究概况
<br><br>
<span style="margin-left:25px"></span>1.3.1 国外对手术器械管理系统的研究
<br><br>
<span style="margin-left:25px"></span>目前RFID技术在医疗领域的运用是多方面的，其在医疗领域的运用，提高了医院的管理效率及治疗效率，产生良好的经济效益和社会效益。
<br><br>
<span style="margin-left:25px"></span>从全球RFID技术在智能手术器械管理系统的研究来看，美国的公司对于智能纱布系统的研究，设计极其应用都走在了世界的前列。
<br><br>
<span style="margin-left:25px"></span>目前，已经主要有三家美国公司相继推出了自己的产品，这三家公司分别是RF Surgical Systems Inc，Patient Safety Technologies Inc和ClearCount Medical Solutions。RF Surgical Systems Inc一个医疗设备公司，总部在华盛顿的贝尔维尤，该公司的产品叫RF Assure Detection System X，包含了两个部分：
<br><br>
<span style="margin-left:25px"></span>带有1bit标签的纱布和扫描检测系统。该系统采用的是传输可靠，非电离性的低频无线电波去探测被标记的纱布，与传统的 RFID技术相比，运用低频的目的是为了信号强度的穿透性好，包括对人体组织，血液，骨骼和附近金属的穿透性，最终也减少海绵留在病人体内的风险。医生能通过该检测系统判断出纱布是否存在于患者体内，然而其局限性在于不能判断出纱布的具体数目以及读取距离不远。Patient Safety Technologies Inc为一家位于加州的医疗器材公司，其主要产品领域为维护病患安全之用品。
<br><br>
<span style="margin-left:25px"></span>该公司的the Safety-Sponge System 产品，可用来计算手术时医材消耗量与使用情况，主要由三部分所组成：带有条码的手术用手术器械、手术次数计数器(扫描器)，以及资料处理系统。它运用小型化的移动电脑为手术室提供了一个实时计数的功能，该扫描系统一直在不断地扫描计数，能够告诉手术人员某种特定类型的海绵是否存在或者失踪，给手术安全提供了保障。然而其局限性在于，对于手术时记录的信息比较少，没有较多的查阅内容。ClearCount Medical Solutions 公司位于宾州，其销售产品为Smart Sponge系统，其主要用途也是用来监测手术进行当中，医用耗材的使用量与情况。
<br><br>
<span style="margin-left:25px"></span>该系统是由内带有RFID感测器的耗材(纱布、手术器具等)，在手术前中后使用RFID扫描器确认其序号，以及是否在正确的位置。据称，SmartSponge System，即智能纱布系统，它是全球首个能够对手术中使用的纱布和海绵进行探测，设别，读取和计数的RFID系统。这个SmartSponge系统可以读取和记录拥有唯一ID号的每个海绵，无论它是用于病人还是被移除处置了。这个系统通过使用无线电波信号的射频识别标签来标示自己，在血液与组织中依然能够找到失踪的标记过得海绵，这为手术安全带来了可靠的保障。其推广的局限性在于生产的成本较高，目前还没有被大规模运用。1.3.2 国内对手术器械管理系统的研究
<br><br>
<span style="margin-left:25px"></span>国内对于射频识别技术的研究起步相对于国外来说是较晚的，各个区域间的发展也相对不平衡。
<br><br>
<span style="margin-left:25px"></span>本世纪初以来，我们国家对RFID技术进行系统地研究并且在大力发展。目前，我国内地的 RFID产业链的雏形也已经基本建设了，主要集中在上海、北京、深圳等地区，其中上海以芯片研究设计为主(例如上海华虹、复旦微电子等)，而深圳则以大力发展了封装、应用方面(如远望谷、先施等)，北京则将主要的精力放在系统集成方案等方面。目前在国内手术医疗中，很注重医疗手术中器械的管理和使用。
<br><br>
<span style="margin-left:25px"></span>由于国内的医疗设备制造行业，较之国外顶尖级的医疗设备制造商，还有很大的差距，导致国内手术过程中器械的使用主要依赖人工清点核对。通过对国内医院手术过程的调研发现，特别是胸腔类手术，为确保器械的规范使用，防止器械遗留在病人体内，避免医疗事故与纠纷，手术中采用严格的三人四次清点制度。对清点的时机，负责清点的人员都做了严格的规定。其中清点纱布的人员有医师助手、医疗器械护士和巡回护士三人组成，然后分四次完成清点工作，并对清点的方法，清点的时间，及其清点时候所要注意的具体事项。如此一来，增加了手术过程中的人员用工成本，操作和管理成本。国内对于智能手术器械管理方面的研究也主要集中在广东地区，已经有一些公司企业对此进行了深入的研究，
<br><br>
<span style="margin-left:25px"></span>并开发出了相应的产品，例如粤发实业有限公司研制出的主要用于医院手术的超高频智能电子纱布标签。然而，由于技术方面的原因，整体的产品性能比较平庸，并没有体现出对于生命安全监测的高可靠性和稳定性。还有另外一家规模较大的公司深圳市新元素医疗技术开发有限公司，成立于2005年，是一家集医疗、 IT和服务于一体，拥有自主知识产权、自有品牌的，专业从事医疗信息化系统集成、系统方案解决、医疗设备生产与经营、医疗相关技术开发与投资的国家高新技术企业、国内远程医疗的领先企业。他们通过与大型医院合作建设网络保健中心与健康小屋的网络医院，并以此为基础，进一步与各类优质健康服务机构合作提供延伸的健康服务，为个人提供自我健康管理的工具和服务支持。公司的产品叫做电子纱布系统，能够准确地统计手术前带进手术室的纱布总数，计算手术过程中丢掉废弃纱布的数量，统计手术完成后未使用的剩余纱布数量，并且能够探测出体内残余纱布的数量以及它们在体内的位置。该系统使用先进的RFID电子标签技术，在纱布内部植入一个大小与一枚硬币相当、厚度不超过4毫米的小型电子标签，与普通纱布几乎无异。特制的电子纱布桶能够扫描、统计与识别这种电子纱布。总体来说，我国对于智能纱布系统的研究相对来说还是很薄弱的，任重而道远。在这几年来，虽然国内运用RFID技术在各个领域取得了较大的进步，但是RFID技术运用于医疗手术器械管理领域还有很多需要研究探索的方面。
<br><br>
<span style="margin-left:25px"></span>到目前为止， RFID技术在中国仍然处于一个初级起步的阶段，而对于医疗行业的运用，特别是智能纱布系统这一研究方向上更是处于萌芽阶段，其发展的空间，市场和潜力都是十分巨大的，前景诱人。1.4 论文的主要研究内容
<br><br>
<span style="margin-left:25px"></span>本文提出了一种基于ISO15693射频标签的射频识别手术器械管理系统。
<br><br>
<span style="margin-left:25px"></span>系统以RFID技术为核心，结合高效的微处理器MCU、精准的现场可编程门阵列器FPGA和友好的Qt图形交互界面，实现了一个稳定、高效的智能化手术器械管理系统。通过对手术器械使用和回收的智能化管理，能够达到有使用就有回收的标准，为手术器械的管理带来了极大的帮助，有效地避免了手术过程中异物遗留问题的发生。第一章绪论对论文的课题来源、研究意义及国内外针对手术器械管理的医疗设备的研究动态做出概述，
<br><br>
<span style="margin-left:25px"></span>指出了本文的主要工作内容和研究目标，同时给出本文的组织结构。第二章介绍RFID射频技术原理，以及RFID的一些相关应用。
<br><br>
<span style="margin-left:25px"></span>并结合ISO15693标签的协议标准和命令集分析其相关特性。第三章结合系统设计开发的生命周期，以从上到下的设计理念，给出手术器械管理系统各部分的组成和整体架构，并对各个部分分别进行了简要分析和描述。
<br><br>
<span style="margin-left:25px"></span>第四章具体介绍了手术器械管理系统硬件部分（RFID阅读部分）的设计。
<br><br>
<span style="margin-left:25px"></span>并分成射频前端电路、FPGA编解码和MCU逻辑控制电路三部分以及之间的连接部分进行详细分析和介绍。第五章具体介绍了手术器械管理系统软件部分的设计。
<br><br>
<span style="margin-left:25px"></span>总体分为MCU端的软件和安装在工控机上的上位机控制软件。介绍的过程中顺带介绍了应用的相关技术和知识，可以使读者更快更易读懂。在第三小节还介绍了专门设计的上位机与MCU通信协议。第六章介绍了在整个手术器械管理系统设计完成之后，根据一些可靠性检测的理论，对系统的准确度和可靠度进行了优化设计。
<br><br>
<span style="margin-left:25px"></span>第七章作为总结和展望部分，对本文所完成的任务做了总结，指出了本文的工作量、创新点和取得的成果，并且提出了今后需要做的工作和下一步努力的方向。
<br><br>
<span style="margin-left:25px"></span>第二章RFID射频技术原理
<br><br>
<span style="margin-left:25px"></span>2.1RFID原理简介
<br><br>
<span style="margin-left:25px"></span>射频识别(RFID)，又称为无线射频识别技术，是无线电频率识别的简称，即通过无线电波进行识别。
<br><br>
<span style="margin-left:25px"></span>它是一种通信技术，即可以通过无线电讯号来识别目标，并进行相关数据读写，获取存放在目标内的电子数据信息，却不需要识别系统和所识别目标之间建立机械或者光学上的接触，整个过程通过无线通信来实现。2.1.1 射频识别系统构成
<br><br>
<span style="margin-left:25px"></span>采用射频识别技术的射频识别系统一般由两个部分组成：
<br><br>
<span style="margin-left:25px"></span>(1)应答器，即标签芯片，放在被识别的物体上。
<br><br>
<span style="margin-left:25px"></span>应答器是射频识别系统的数据载体。通常，应答器由耦合元件以及微电子芯片组成。(2)阅读器，一种可以读写标签芯片的装置。
<br><br>
<span style="margin-left:25px"></span>它通过发送请求命令，并等待应答器的应答，对应答信号进行读取。另外，许多阅读器还会附加各种接口，以便将从应答器读取的数据传输给上级系统，如个人计算机等。图2-1所示为 RFID系统的基本单元，右边为具备耦合元件的阅读器，左边为含有耦合元件的应答器，
<br><br>
<span style="margin-left:25px"></span>二者通过各自的耦合元件建立起无线通信，通过电磁耦合的方式实现能量传输以及数据传输。图2-1 RFID系统简图
<br><br>
<span style="margin-left:25px"></span>2.1.2 射频识别系统分类
<br><br>
<span style="margin-left:25px"></span>根据不同的分类标准，RFID系统可以有多种分类，以下是几种比较常见的分类。
<br><br>
<span style="margin-left:25px"></span>1.根据标签的供电方式
<br><br>
<span style="margin-left:25px"></span>根据标签供电方式的不同，行业将标签分为有源标签和无源标签。
<br><br>
<span style="margin-left:25px"></span>有源标签指的是在标签内部自身含有电池，标签的工作用电由电池供应。这样的RFID系统称为主动射频系统。有源标签适合远距离、高速度读写数据，而且可以主动发送射频信号和阅读器进行通信。但是此种标签体积大、价格高，而且使用寿命受限于电池而较短。无源标签则是内部没有电源，主要通过耦合阅读器的射频信号来获取能量。此种RFID系统也称为被动射频系统。无源标签读写距离较短，但是其体积小、价格低且使用寿命较长。2.根据RFID系统工作频率
<br><br>
<span style="margin-left:25px"></span>根据RFID系统的工作频段分，可以分为四种：
<br><br>
<span style="margin-left:25px"></span>低频系统（30-300KHz）、高频系统（3-30MHz）、超高频系统（300-2.45GHz）和微波系统（2.45GHz以上）如表2-1所示。表2-1 RFID芯片分类
<br><br>
<span style="margin-left:25px"></span>低频
<br><br>
<span style="margin-left:25px"></span>高频
<br><br>
<span style="margin-left:25px"></span>超高频
<br><br>
<span style="margin-left:25px"></span>微波
<br><br>
<span style="margin-left:25px"></span>工作频率
<br><br>
<span style="margin-left:25px"></span>125~134KHz
<br><br>
<span style="margin-left:25px"></span>13.56MHz
<br><br>
<span style="margin-left:25px"></span>JM13.556MHz
<br><br>
<span style="margin-left:25px"></span>868~915MHz
<br><br>
<span style="margin-left:25px"></span>2.45~5.8GHz
<br><br>
<span style="margin-left:25px"></span>市场占有率
<br><br>
<span style="margin-left:25px"></span>74%
<br><br>
<span style="margin-left:25px"></span>17%
<br><br>
<span style="margin-left:25px"></span>0%
<br><br>
<span style="margin-left:25px"></span>6%
<br><br>
<span style="margin-left:25px"></span>3%
<br><br>
<span style="margin-left:25px"></span>读取距离
<br><br>
<span style="margin-left:25px"></span>1.2m
<br><br>
<span style="margin-left:25px"></span>1.2m
<br><br>
<span style="margin-left:25px"></span>1.2m
<br><br>
<span style="margin-left:25px"></span>4m（美国）
<br><br>
<span style="margin-left:25px"></span>15m（美国）
<br><br>
<span style="margin-left:25px"></span>速度
<br><br>
<span style="margin-left:25px"></span>中等
<br><br>
<span style="margin-left:25px"></span>很快
<br><br>
<span style="margin-left:25px"></span>很快
<br><br>
<span style="margin-left:25px"></span>潮湿环境
<br><br>
<span style="margin-left:25px"></span>无影响
<br><br>
<span style="margin-left:25px"></span>无影响
<br><br>
<span style="margin-left:25px"></span>无影响
<br><br>
<span style="margin-left:25px"></span>影响较大
<br><br>
<span style="margin-left:25px"></span>影响较大
<br><br>
<span style="margin-left:25px"></span>方向性
<br><br>
<span style="margin-left:25px"></span>部分
<br><br>
<span style="margin-left:25px"></span>全球适用频率
<br><br>
<span style="margin-left:25px"></span>部分（欧盟、美国）
<br><br>
<span style="margin-left:25px"></span>部分（非欧盟国家）
<br><br>
<span style="margin-left:25px"></span>现有ISO标准
<br><br>
<span style="margin-left:25px"></span>11784/85、14223
<br><br>
<span style="margin-left:25px"></span>18000-3/1
<br><br>
<span style="margin-left:25px"></span>14443
<br><br>
<span style="margin-left:25px"></span>18000-3/2
<br><br>
<span style="margin-left:25px"></span>15693，A，B和C
<br><br>
<span style="margin-left:25px"></span>EPC C0，C1，C2，G2
<br><br>
<span style="margin-left:25px"></span>18000-4
<br><br>
<span style="margin-left:25px"></span>主要应用范围
<br><br>
<span style="margin-left:25px"></span>进出管理、固定设备，洗衣店
<br><br>
<span style="margin-left:25px"></span>图书馆、产品跟踪、货架、运输
<br><br>
<span style="margin-left:25px"></span>空运、邮局、医药、烟草
<br><br>
<span style="margin-left:25px"></span>货架、卡车、拖车跟踪
<br><br>
<span style="margin-left:25px"></span>收费站、集装箱
<br><br>
<span style="margin-left:25px"></span>其中，在低频系统中常用的频率为125KHz和134KHz，适合近距离的场合，如门禁、动物耳标等。
<br><br>
<span style="margin-left:25px"></span>高频系统中常用的频率为13.56MHz，适合信用卡、资产管理等。超高频系统常用的频率为860MHz-915MHz，适用于远距离场合工作，例如车辆跟踪，物流管理等。微波系统中一般工作频率为2.45GHz和5.8GHz，比较适合较远距离的场合，高速公路收费系统等。3.根据标签的存储器类型
<br><br>
<span style="margin-left:25px"></span>根据标签存储单元的类型一般将RFID系统划分为：
<br><br>
<span style="margin-left:25px"></span>只读型、一次写入、多次重复读写。只读型为标签在出厂时信息已经固定，对于用户来说只能够读取标签信息，但是无权修改。该系统可用于门禁物流管理等。一次写入标签只允许用户写入数据一次，一旦写入后不得修改，只可读。此种系统一般用于资产管理等贵重物品管理。多次重复读写标签允许用户可以任意次读写标签数据，此类系统一般用于信用卡服务等。2.1.3 RFID标签
<br><br>
<span style="margin-left:25px"></span>RFID标签具有条形码所不具备的防水、防磁、耐高温、使用寿命长、读取距离大、标签信息加密、存储数量容量大、存储信息可更改等优点。
<br><br>
<span style="margin-left:25px"></span>常见的RFID标签如图2-2所示：图2-2 常见的RFID标签
<br><br>
<span style="margin-left:25px"></span>RFID标签主要性能参数：
<br><br>
<span style="margin-left:25px"></span>工作频率
<br><br>
<span style="margin-left:25px"></span>读/写能力
<br><br>
<span style="margin-left:25px"></span>编码调制方式
<br><br>
<span style="margin-left:25px"></span>数据传输速率
<br><br>
<span style="margin-left:25px"></span>信息数据存储容量
<br><br>
<span style="margin-left:25px"></span>工作距离
<br><br>
<span style="margin-left:25px"></span>多应答器识读能力（亦称防碰撞或防冲突能力）
<br><br>
<span style="margin-left:25px"></span>安全性能（密钥、认证）等。
<br><br>
<span style="margin-left:25px"></span>RFID标签的内部结构主要是RFID芯片和天线组成，具体如图2-3所示：
<br><br>
<span style="margin-left:25px"></span>图2-3 RFID标签的内部结构
<br><br>
<span style="margin-left:25px"></span>RFID芯片内部电路主要由射频前端的接收和发射电路、电源电路、逻辑控制电路和存储器件组成。
<br><br>
<span style="margin-left:25px"></span>基本结构如下图2-4所示：图2-4 RFID芯片内部结构图
<br><br>
<span style="margin-left:25px"></span>2.1.4 RFID阅读器
<br><br>
<span style="margin-left:25px"></span>一台典型的阅读器包含高频模块（发送和接收器）、控制单元以及与标签的耦合元件。
<br><br>
<span style="margin-left:25px"></span>此外，许多阅读器还都有附加的接口（RS232、RJ45、WIFI等），以便将获取的数据向更高层系统传送。阅读器的电路组成如图2-5所示：
<br><br>
<span style="margin-left:25px"></span>图2-5 阅读器电路结构图
<br><br>
<span style="margin-left:25px"></span>阅读器的功能:
<br><br>
<span style="margin-left:25px"></span>以射频方式向应答器传输能量；
<br><br>
<span style="margin-left:25px"></span>从应答器中读出数据或向应答器写入数据；
<br><br>
<span style="margin-left:25px"></span>完成对读取数据的信息处理并实现应用操作；
<br><br>
<span style="margin-left:25px"></span>若有需要，应能和高层处理交互信息。
<br><br>
<span style="margin-left:25px"></span>常见的阅读器如图2-6所示：
<br><br>
<span style="margin-left:25px"></span>图2-6 常见的阅读器
<br><br>
<span style="margin-left:25px"></span>2.2 RFID应用介绍
<br><br>
<span style="margin-left:25px"></span>目前射频识别按载波频率分为低频（LF）、高频（HF）、超高频（UHF）和微波（MW）。
<br><br>
<span style="margin-left:25px"></span>因为不同波段的无线电波具有不同特性，各个频段的射频识别具有不同的应用场景。低频的频率主要为：
<br><br>
<span style="margin-left:25px"></span>125kHz和134.2kHz。由于该频段在金属和液体背景下有较好的性能，目前主要应用于动物体内外标签，门禁及危险品钢瓶，蔬菜水果肉类运输标签。常用只读形式，也有少量读写芯片。该类芯片通常不加密。高频的频率主要为：13.56MHz。由于该频段天线简单体积小，有加密，主要用于证票类，一般为读写卡。该卡又分逻辑卡和CPU卡。逻辑卡是最常用，如身份证，门票，交通卡，它的简化版用于一次性车票，如铁路客票。由于高度信息安全CPU卡将用的越来越多，如身份证，交通卡，银行卡，而逻辑卡则逐步退到门禁等领域。在这个频段还有由于手机支付等应用的NFC（短距离无线通信）。超高频的频率主要为：433MHz和915MHz。常用于于有源形式。有十几米的识别距离。915MHz也常有无源形式，物流和车牌用的多。微波的频率主要为：2.45GHz、5.8GHz。该频段都为有源。识别距离远，方向性好。2.45GHz常用于集装箱，和水路。5.8GHz常用于道路收费。2.3 ISO15693标签
<br><br>
<span style="margin-left:25px"></span>目前，国际上有许多针对RFID芯片的协议。
<br><br>
<span style="margin-left:25px"></span>分别在不同的频率范围内都有相应的协议规范。在13.56MHz的频率下，有ISO/IEC-14443系列、ISO/IEC-15693等协议，各种协议下的RFID标签芯片可以适用在不同的场合。本文用到的RFID芯片是一款满足ISO/IEC-15693协议的高频芯片，在现代生活中，可以应用在产品供应链管理、图书管理、防伪等领域，具有广泛的应用市场。2.3.1 ISO15693标签的协议分析
<br><br>
<span style="margin-left:25px"></span>阅读器(Vicinity Coupling Device，VCD)和标签芯片（Vicinity Card，VICC）的通信采用命令帧格式传输。
<br><br>
<span style="margin-left:25px"></span>表2-2为 VCD到 VICC的请求命令帧格式，帧格式包括帧头 SOF（ Start of Frame），请求标志（ Flag），命令码（ Command），若干参数（ Parameter）与数据（ Data），最后是 CRC（ Cyclic Redundancy Check）校验和帧尾 EOF（ End of Frame）。根据每条命令的不同，帧格式中的参数和数据也不同。VICC到VCD的响应帧格式比请求帧格式中少了命令码项，其余部分格式相同。表2-2请求命令帧格式
<br><br>
<span style="margin-left:25px"></span>SOF
<br><br>
<span style="margin-left:25px"></span>Flag
<br><br>
<span style="margin-left:25px"></span>Command
<br><br>
<span style="margin-left:25px"></span>Parameter
<br><br>
<span style="margin-left:25px"></span>Data
<br><br>
<span style="margin-left:25px"></span>CRC
<br><br>
<span style="margin-left:25px"></span>EOF
<br><br>
<span style="margin-left:25px"></span>8 bits
<br><br>
<span style="margin-left:25px"></span>8 bits
<br><br>
<span style="margin-left:25px"></span>m bits
<br><br>
<span style="margin-left:25px"></span>n bits
<br><br>
<span style="margin-left:25px"></span>16 bits
<br><br>
<span style="margin-left:25px"></span>注:
<br><br>
<span style="margin-left:25px"></span> m、n均为8的非负整数倍协议规定了其通信命令帧的编码模式也有多种。
<br><br>
<span style="margin-left:25px"></span>以下简要介绍芯片通信的编码模式。VCD到VICC的通信编码模式
<br><br>
<span style="margin-left:25px"></span>VCD到VICC的通信编码模式有两种，一种是256取1，另外一种是4取1，两种编码模式通信速率不同，适用的场合也不同[33]。
<br><br>
<span style="margin-left:25px"></span>1.
<br><br>
<span style="margin-left:25px"></span> VCD到VICC的SOF编码如图2-7所示，为 SOF的两种编码模式，上面的是256取1编码的 SOF，
<br><br>
<span style="margin-left:25px"></span>下面一种为4取1编码的 SOF，两种编码方式都是在第一个开始的9.44 us产生一个暂停（ pause）状态，并且都总共持续了两个37.76 us。不同的是第二个pause产生的位置不同，从图中可以看到256取1的编码方式是在最后，不同于4取1编码。//
<br><br>
<span style="margin-left:25px"></span>图2-7 VCD到VICC的SOF编码
<br><br>
<span style="margin-left:25px"></span>2.
<br><br>
<span style="margin-left:25px"></span> VCD到VICC的EOF编码这里的EOF编码，无论VCD采用何种编码方式，EOF只有一种形式，如图2-8所示。
<br><br>
<span style="margin-left:25px"></span>从图中可以看出，pause产生在倒数第二个9.44us处。图2-8 VCD到VICC的EOF编码
<br><br>
<span style="margin-left:25px"></span>3.
<br><br>
<span style="margin-left:25px"></span>VCD到VICC的数据编码(1)256取1编码模式
<br><br>
<span style="margin-left:25px"></span>此种编码模式采用一个字节产生一个pause的位置的方式来表示被编码的字节。
<br><br>
<span style="margin-left:25px"></span>所以，每次编码为一个字节，在256个连续的18.88us中，通过被编码的字节的数值，决定pause产生的位置。如数据E1，其十进制位225，则在第225个18.88us的后半部分产生一个pause，如下图2-9所示。这样传输一个字节需要4.833ms，数据速率为1.54kbits/s。图2-9 256取1编码模式图
<br><br>
<span style="margin-left:25px"></span>(2)4取1编码模式
<br><br>
<span style="margin-left:25px"></span>此种编码方式为每2bits编码，在连续4个18.88us中，根据2bits值来决定产生pause的位置，如图3-5所示。
<br><br>
<span style="margin-left:25px"></span>从图2-10中可以看到，如果被编码的2bits为00，则在第0个18.88us的后半个位置处产生一个9.44us的pause，其余编码依次类推。这种编码模式一个bit需要2个18.88us，所以数据速率为26.48kbits/s。图2-10 4取1编码模式图
<br><br>
<span style="margin-left:25px"></span>VICC到VCD的通信编码模式
<br><br>
<span style="margin-left:25px"></span>从VICC到VCD的通信采用负载调制，通过载波来产生需要频率的副载波。
<br><br>
<span style="margin-left:25px"></span>在通讯中，有 VCD控制 VICC选择使用一种或者两种副载波，当使用一种副载波时，频率 fs1为 fc/32，当使用两种副载波时，其另外一种副载波频率 fs2为 fc/28。另外， VCD还可以通过请求命令的 flag配置 VICC的返回采用高速通信还是低速通信，下面介绍 VICC到 VCD的编码方式均是高速通信的编码方式，对于低速编码方式，则使用同样的副载波，但是脉冲数是原来的4倍。1.
<br><br>
<span style="margin-left:25px"></span>VICC到VCD的数据编码VICC到VCD的数据编码采用曼彻斯特编码，如图2-11所示。
<br><br>
<span style="margin-left:25px"></span>图上半部分是逻辑0的编码，以频率fs1的8个脉冲开始，接着是约18.88us的非调制时间。而下半部分是逻辑1的编码，与逻辑0的编码恰好相反。所以一个bit传输的时间是37.76us，即通信速率为26.48kbits/s。这是采用单副载波的编码，对于双副载波，即是对非调制部分，采用频率fs2的9个脉冲进行调制。计算得出传输速率为6.67 kbits/s。以下双副载波编码方式同样如此，不在赘述，仅介绍单副载波模式。//
<br><br>
<span style="margin-left:25px"></span>图2-11 VICC到VCD的单副载波数据编码
<br><br>
<span style="margin-left:25px"></span>2.
<br><br>
<span style="margin-left:25px"></span>VICC到VCD的SOF如图2-12所示，SOF包含三个部分，分别是一个56.64us的非调制时间、频率为fs1的24个脉冲和一个逻辑1。
<br><br>
<span style="margin-left:25px"></span>图2-12 VICC到VCD的单副载波SOF
<br><br>
<span style="margin-left:25px"></span>3.
<br><br>
<span style="margin-left:25px"></span>VICC到VCD的EOF如图2-13所示，EOF也包含三个部分，分别是一个逻辑0、频率为fs1的24个脉冲和一个56.64us的非调制时间。
<br><br>
<span style="margin-left:25px"></span>图2-13 VICC到VCD的单副载波EOF
<br><br>
<span style="margin-left:25px"></span>2.3.2 ISO15693标签常用的命令集
<br><br>
<span style="margin-left:25px"></span>标签在场强中工作，与阅读器的通信执行不同的动作是通过不同的命令来实现的，即表2-2所描述的命令帧中的Command，也就是说，一个标签必须具备一个命令集。
<br><br>
<span style="margin-left:25px"></span>ISO/IEC-15693协议就规定了一系列的命令集以及扩充命令集的规则。表2-3就是15693协议所规定的命令集。表2-3 15693协议命令集
<br><br>
<span style="margin-left:25px"></span>命令码
<br><br>
<span style="margin-left:25px"></span>类型
<br><br>
<span style="margin-left:25px"></span>功能描述
<br><br>
<span style="margin-left:25px"></span>01
<br><br>
<span style="margin-left:25px"></span>强制
<br><br>
<span style="margin-left:25px"></span>寻卡
<br><br>
<span style="margin-left:25px"></span>02
<br><br>
<span style="margin-left:25px"></span>强制
<br><br>
<span style="margin-left:25px"></span>标签进入静默状态
<br><br>
<span style="margin-left:25px"></span>03-1F
<br><br>
<span style="margin-left:25px"></span>强制
<br><br>
<span style="margin-left:25px"></span>留作以后使用
<br><br>
<span style="margin-left:25px"></span>20
<br><br>
<span style="margin-left:25px"></span>可选
<br><br>
<span style="margin-left:25px"></span>读单个块数据
<br><br>
<span style="margin-left:25px"></span>21
<br><br>
<span style="margin-left:25px"></span>可选
<br><br>
<span style="margin-left:25px"></span>写单个块数据
<br><br>
<span style="margin-left:25px"></span>22
<br><br>
<span style="margin-left:25px"></span>可选
<br><br>
<span style="margin-left:25px"></span>锁单个块数据
<br><br>
<span style="margin-left:25px"></span>23
<br><br>
<span style="margin-left:25px"></span>可选
<br><br>
<span style="margin-left:25px"></span>读多个块数据
<br><br>
<span style="margin-left:25px"></span>24
<br><br>
<span style="margin-left:25px"></span>可选
<br><br>
<span style="margin-left:25px"></span>写多个块数据
<br><br>
<span style="margin-left:25px"></span>25
<br><br>
<span style="margin-left:25px"></span>可选
<br><br>
<span style="margin-left:25px"></span>标签进入选择状态
<br><br>
<span style="margin-left:25px"></span>26
<br><br>
<span style="margin-left:25px"></span>可选
<br><br>
<span style="margin-left:25px"></span>标签进入复位状态
<br><br>
<span style="margin-left:25px"></span>27
<br><br>
<span style="margin-left:25px"></span>可选
<br><br>
<span style="margin-left:25px"></span>写AFI数据
<br><br>
<span style="margin-left:25px"></span>28
<br><br>
<span style="margin-left:25px"></span>可选
<br><br>
<span style="margin-left:25px"></span>锁AFI数据
<br><br>
<span style="margin-left:25px"></span>29
<br><br>
<span style="margin-left:25px"></span>可选
<br><br>
<span style="margin-left:25px"></span>写DSFID数据
<br><br>
<span style="margin-left:25px"></span>2A
<br><br>
<span style="margin-left:25px"></span>可选
<br><br>
<span style="margin-left:25px"></span>锁DSFID数据
<br><br>
<span style="margin-left:25px"></span>2B
<br><br>
<span style="margin-left:25px"></span>可选
<br><br>
<span style="margin-left:25px"></span>获取标签信息
<br><br>
<span style="margin-left:25px"></span>2C
<br><br>
<span style="margin-left:25px"></span>可选
<br><br>
<span style="margin-left:25px"></span>获取标签多个块安全状态
<br><br>
<span style="margin-left:25px"></span>2D-9F
<br><br>
<span style="margin-left:25px"></span>可选
<br><br>
<span style="margin-left:25px"></span>留作以后使用
<br><br>
<span style="margin-left:25px"></span>A0-DF
<br><br>
<span style="margin-left:25px"></span>定制
<br><br>
<span style="margin-left:25px"></span>IC 制造商决定
<br><br>
<span style="margin-left:25px"></span>E0-FF
<br><br>
<span style="margin-left:25px"></span>私有
<br><br>
<span style="margin-left:25px"></span>IC 制造商决定
<br><br>
<span style="margin-left:25px"></span>上表中，第一列为命令编码，使用一个Byte来表示，第二列为命令的类型，第三列为命令的功能描述。
<br><br>
<span style="margin-left:25px"></span>首先是01和02命令，是强制命令，也就是凡是满足此协议的标签芯片必须支持这两条命令。而03-1F命令也是强制命令，但是协议还没有规定功能，只是用来以后的协议扩充使用。20-2C这些命令对于标签芯片是可选择的。2D-9F同样留作以后使用。2.3.3ISO15693标签特点分析
<br><br>
<span style="margin-left:25px"></span>ISO15693标签工作频率为：
<br><br>
<span style="margin-left:25px"></span>13.56MHz7kHz，属于高频标签。 ISO15693标签具有一个8字节共64 bit的全球唯一序列号( UID)，这个 UID一方面可以使全球范围内的标签互相区别，更重要的是可以在多标签同时读写时用于防冲突。ISO用一个字节的AFI (Application family identifier)来区分不同行业中的电子标签。AFI的高半字节表示主要行业，低半字节表示主要行业中的细分行业。15693国际标准还规定了一个字节的可选的数据存储格式识别符(DSFID)，用来区分标签中不同的数据存储格式。如果标签支持DSFID，在清点命令中标签将返回一个非零的DSFID，读写器可据此判断射频场中的标签是否具有期望的数据格式。电子标签的内存最大可达8K字节，以数据块(Block)为单位进行管理，标签内最多可以有256个数据块，每个数据块最大可以有32字节。数据块的内容可以锁定以防止修改。标签具有4个相互转换的状态：Power off状态：在标签未进入到有效磁场区域时标签处于Power off状态；Ready 状态：被激活后选择表示未设立时，处理任何请求；Quiet 状态：不处理任何标签清点指令，可接受直接寻址的命令；Select状态：仅响应选择标识符设置的请求。图2-14 ISO15693芯片内部状态转换图
<br><br>
<span style="margin-left:25px"></span>综合来看此波段的特点为：
<br><br>
<span style="margin-left:25px"></span>读取距离在10cm到1m不等，芯片具有抗冲突特性，用于读取环境具有多张标签，距离适中的场景。典型应用包括：电子车票、电子闭锁防盗（电子遥控门锁控制器）、小区物业管理、大厦门禁系统、物联网系统等。2.3本章小结
<br><br>
<span style="margin-left:25px"></span>本章开头从RFID原理开始分析和介绍，大体从RFID系统的组成、RFID的分类、各个频段RFID芯片和阅读器研究介绍，让读者对RFID系统原理和组成有一个大体的了解。
<br><br>
<span style="margin-left:25px"></span>后面对本文要用到的 ISO15693协议进行了分析和研究，分析了协议中的编码解码规定，以及标签与阅读器之间的通信方式的规范，并结合 ISO15693芯片的命令集含义进行介绍，这些重要的协议内容有助于后面对文章标签阅读部分的理解和依据。最后分析了ISO15693标签的物理特性和应用场景，变相的说明了本文手术器械管理系统为何选用ISO15693RFID标签的原因。本章总体上介绍了什么是RFID，RFID有哪些分类，RFID系统的组成，ISO15693协议规定了什么内容和为何本文选用ISO15693标签。第三章手术器械管理系统架构原理分析与设计
<br><br>
<span style="margin-left:25px"></span>3.1 系统整体结构规划设计
<br><br>
<span style="margin-left:25px"></span>手术器械管理系统的开发周期是指从该系统产生到该系统停止应用的整个周期。
<br><br>
<span style="margin-left:25px"></span>这里我们可以将手术器械管理系统生存周期人为的划分为：手术器械管理的问题定义阶段、手术器械管理的需求分析阶段、手术器械管理的软件架构阶段、系统的编码与测试阶段、运行和维护阶段等。3.1.1 手术器械管理系统的需求分析
<br><br>
<span style="margin-left:25px"></span>把手术器械管理系统的开发周期大致分为：
<br><br>
<span style="margin-left:25px"></span>需求分析、提出解决方案、设计实现、实施部署，测试与评估。之后如果市场、客户等对该手术器械管理系统还有其他新增的需求或者功能要求，我们将再次提出需求分析，提出解决方案循环往复，这就是我们采用的周期模式中的迭代式模式，每次迭代都会产生一个可以发布的产品。手术器械管理系统开发遵循的迭代思想可以用下图3-1展示：图3-1 手术器械管理系统设计周期
<br><br>
<span style="margin-left:25px"></span>识别需求是该手术器械管理系统生命周期的最初阶段。
<br><br>
<span style="margin-left:25px"></span>需求分析主要是指理解用户的需求，整理出系统的功能，并尽量满足用户所提出的要求。然后我们需要评估开发该系统的风险系数，以及所需要的成本和代价，最终生成一份开发计划。就该手术器械管理系统而言，这个阶段的主要任务是确认需求，研究项目的可行性，分析自身具备的条件，分析投资和收益比等。从客户的角度出发确认需求，手术器械管理系统要求能够准确记录进入无菌区的手术器械和所使用的手术器械，
<br><br>
<span style="margin-left:25px"></span>确保没有手术器械残留与病人体内，并给用户提供友好美观的交互界面；可行性方面，借助RFID追踪技术可以实现多手术器械的追踪和定位，并借助Qt技术实现对众多纱布信息的管理以及为用户提供友好和美观的操作界面；我们实验室已经具备独立设计完成RFID标签芯片和阅读器的能力，可以整合本实验室的RFID方面的技术，完成智能纱布系统的设计，并将其推广到市场上，实现其市场价值。3.1.2 手术器械管理系统系统框图
<br><br>
<span style="margin-left:25px"></span>在详细分析了智能纱布系统需求之后，我们便要设计该系统的解决方案。
<br><br>
<span style="margin-left:25px"></span>由于整个手术器械管理系统涉及的方面很多，功能非常的复杂，不管是系统的硬件方面还是软件方面都有各自的差异性。比如软件系统上既有面向底层硬件的接口程序，又有面向高级应用的面向对象程序；而硬件方面及存在数字电路又有射频模拟电路等。自顶向下的设计方法是开发复杂系统的推荐方法，对于此复杂的智能纱布系统的设计我们一般采用自顶向下的设计方法，先制定高层规划，将系统分割成若干模块，从高层规划向下逐步细化，下图3-2详细展示了手术器械管理系统各个模块功能和之间的关系。图3-2 自顶向下设计规划系统框图
<br><br>
<span style="margin-left:25px"></span>遵循自顶向下和模块化的设计思想，增强了系统的可扩展性和通用性，如上图所示，将手术器械管理系统各个部分构成划分为以下：
<br><br>
<span style="margin-left:25px"></span>嵌入有 RFID标签的手术器械，基于自动识别的 RFID阅读器手术器械读入部分，用于处理废弃手术器械的回收处理系统，检测意外遗留在病人体内手术器械的扫描部分，以上部分都是由安装在工控机上 Qt开发的上位机软件来协调和控制。3.1.3手术器械管理系统的实现方案
<br><br>
<span style="margin-left:25px"></span>设计实现阶段的工作是提出手术器械管理系统解决方案后工作的延续。
<br><br>
<span style="margin-left:25px"></span>针对上述需求，本文提出了一种基于ISO15693射频标签的RFID手术器械管理系统。系统以射频识别（ RFID）技术为核心，结合微处理器（ MCU）的高效，利用现场可编程门阵列（ FPGA）的精准，凭借 Qt友好的图形交互界面，最终实现了一个稳定、高效的智能化手术器械管理系统。通过对手术器械使用和回收情况的智能化管理，达到有使用就有回收的标准，为手术器械的使用和回收管理带来了极大的帮助，有效地避免了手术过程中异物遗留问题的发生。手术器械管理系统主要由内嵌射频识别标签的手术器械、读卡机系统、工控机等部分组成。
<br><br>
<span style="margin-left:25px"></span>阅读器系统由三通道天线、射频前端模块、FPGA编解码模块、MCU控制模块组成，主要完成对射频识别标签的登记录入、回收统计和寻找扫描。天线完成发射和接收磁场信号，射频前端模块实现电信号与磁场信号的相互转换， FPGA编解码模块负责将通信数据根据 ISO15693协议进行编码和解码， MCU控制模块控制硬件电路的逻辑动作并与上位机进行通信。工控机端安装了Qt开发的上位机程序，通过RS232串口与读卡机系统通信，显示系统的操作管理界面并完成数据处理和分类。手术器械管理系统整体结构框图3-3如下：图3-3手术器械管理系统整体结构框图
<br><br>
<span style="margin-left:25px"></span>3.2RFID标签选型以及系统相关要求参数说明
<br><br>
<span style="margin-left:25px"></span>根据第二章中对RFID标签分类的介绍可知，RFID标签可以分为四种：
<br><br>
<span style="margin-left:25px"></span>低频系统（30-300KHz）、高频系统（3-30MHz）、超高频系统（300-2.45GHz）和微波系统（2.45GHz以上）。这四种因其工作频率的不同各有各的特性，因此适用的场合也不同。本系统根据相关实际应用需求进行选型。3.2.1手术器械管理系统的相关参数要求
<br><br>
<span style="margin-left:25px"></span>手术器械管理系统整个设计的使用过程如下：
<br><br>
<span style="margin-left:25px"></span>手术开始打开手术管理系统，点击操作界面的登记录入按钮，将手术器械使用前在登记录入天线处扫描录入，器械使用完后扔进回收桶中。手术结束后点击回收按钮，系统自动统计回收桶中的器械。根据系统显示结果判断，如果有未回收的遗漏器械，点击扫描按钮用扫描天线去病人身体部位探测寻找，快速定位遗漏器械的位置。手术器械管理系统适用场景要求能够准确记录进入无菌区的手术器械和所使用的手术器械，确保没有手术器械残留与病人体内。在登记录入天线、回收桶天线和扫描天线处读取 RFID时都会出现同时读取多张标签的情况，另外扫描天线需要读取距离在50 cm左右这样才能确保整个人身体部位都能被读取，但读取距离又不能太远这样整个手术室内的标签都会被读取。总体上来说手术器械管理系统的参数要求为：1.能够同时读取多张RFID标签及RFID的抗冲突特性；2.读取距离小于70cm，其中扫描天线读取距离大于50cm。3.2.1手术器械管理系统的RFID标签选型
<br><br>
<span style="margin-left:25px"></span>四种RFID标签一些应用特点如下：
<br><br>
<span style="margin-left:25px"></span>1.低频系统中常用的频率为125KHz和134KHz，不具备抗冲突特性，适合近距离的场合，如门禁、动物耳标等。
<br><br>
<span style="margin-left:25px"></span>2.高频系统中常用的频率为13.56MHz，具备抗冲突，读取距离适中，适合信用卡、资产管理等。
<br><br>
<span style="margin-left:25px"></span>3.超高频系统常用的频率为860MHz-915MHz，具备抗冲突，适用于远距离场合工作，例如车辆跟踪，物流管理等。
<br><br>
<span style="margin-left:25px"></span>4.微波系统中一般工作频率为2.45GHz和5.8GHz，具备抗冲突，比较适合较远距离的场合，高速公路收费系统等
<br><br>
<span style="margin-left:25px"></span>根据上一节分析的手术器械管理系统的相关参数要求：
<br><br>
<span style="margin-left:25px"></span>1.能够同时读取多张RFID标签及RFID的抗冲突特性；2.读取距离小于70cm，其中扫描天线读取距离大于50cm。只有高频系统适用，所以选取ISO15693协议的RFID标签，作为手术器械管理系统的工作RFID标签用来标识和跟踪手术器械。3.3天线分布与设计概述
<br><br>
<span style="margin-left:25px"></span>3.3.1手术器械管理系统天线设计的基本要求
<br><br>
<span style="margin-left:25px"></span>手术器械管理系统的阅读器和手术器械内的电子标签之间的电感耦合主要通过天线间的耦合来实现，
<br><br>
<span style="margin-left:25px"></span>以此来传输能量与信息，手术器械管理系统阅读器天线设计的好坏直接影响到阅读器与手术器械内的电子标签之间的耦合效果。由于手术器械管理系统的天线用于产生磁通量，给手术器械内的电子标签提供电源使其正常工作。因此，对智能纱布阅读仪天线的设计有几个基本要求：1）线圈天线的电流尽可能大从而产生最大的磁通量；
<br><br>
<span style="margin-left:25px"></span>2）功率匹配良好，最大限度的利用阅读器传输的能量；
<br><br>
<span style="margin-left:25px"></span>3）足够的带宽，使得载波信号能正常传送。
<br><br>
<span style="margin-left:25px"></span>在设计手术器械管理系统时，对手术器械管理系统的阅读器的识别距离是有要求的。
<br><br>
<span style="margin-left:25px"></span>影响手术器械管理系统识别距离的主要因素有:1)手术器械管理系统的阅读器和纱布内的电子标签天线的几何尺寸；
<br><br>
<span style="margin-left:25px"></span>2)天线的匹配电路设计；
<br><br>
<span style="margin-left:25px"></span>3)天线与匹配电路的品质因数；
<br><br>
<span style="margin-left:25px"></span>4)手术器械管理系统的阅读器天线的输入功率；
<br><br>
<span style="margin-left:25px"></span>5)内外环境的影响。
<br><br>
<span style="margin-left:25px"></span>3.3.2系统天线的结构
<br><br>
<span style="margin-left:25px"></span>手术器械管理系统的天线也是工作于13.56 MHz，是利用电感耦合型的 RFID系统，目前，市场上流通的阅读器的天线都普遍采用线圈型结构，
<br><br>
<span style="margin-left:25px"></span>主要是利用了其结构简单，成本较低的特点。常见的线圈型天线有圆形和矩形（PCB平面印制），天线的匝数，印制的层数，可能是单匝层，也可能是多匝层结构的。两种主要的结构如图3-4所示：图3-4阅读器天线的主要结构
<br><br>
<span style="margin-left:25px"></span>3.3.3 天线尺寸的理论分析
<br><br>
<span style="margin-left:25px"></span>工作于13.56MHz的手术器械管理系统的线圈天线，其工作波长22.12m远大于其电尺寸，可归为小环形天线。
<br><br>
<span style="margin-left:25px"></span>我们可以通过对小环形通电导体磁场分布特点的研究，得到阅读器天线的磁场强度及其可能的影响因数。由安培定律克制：
<br><br>
<span style="margin-left:25px"></span>电流流经一段导体时在导体周围产生磁场，如图3-5所示。图3-5导线处产生的磁场
<br><br>
<span style="margin-left:25px"></span>磁感应强度大小的表达式如下：
<br><br>
<span style="margin-left:25px"></span>(3.1)
<br><br>
<span style="margin-left:25px"></span>可知，当电流流经一段导体时，会在导体周围产生磁场，磁场的磁感应强度大小与流经导体的电流I成正比，与距导体的半径r成反比。
<br><br>
<span style="margin-left:25px"></span>根据毕奥-萨伐尓定律：
<br><br>
<span style="margin-left:25px"></span>(3.2)
<br><br>
<span style="margin-left:25px"></span>可得出，在距离天线线圈中心垂直距离为r处的磁感应强度B的大小为：
<br><br>
<span style="margin-left:25px"></span>(3.3)
<br><br>
<span style="margin-left:25px"></span>又因为R2=r2+a2，代入上式3.7，得到图3-6中点p处的磁感应强度的大小为：
<br><br>
<span style="margin-left:25px"></span>(3.4)
<br><br>
<span style="margin-left:25px"></span>式中，0为真空磁导率，r为离线圈中心的垂直距离， a为线圈边长，I为电流值，N为线圈匝数。
<br><br>
<span style="margin-left:25px"></span>图3- 6环形线圈的磁场
<br><br>
<span style="margin-left:25px"></span>由上式可知，当r[[a的的时候，其范围内的磁感应强度基本上没有变化；
<br><br>
<span style="margin-left:25px"></span>当r=0时，表达式也可化简为：(3.5)
<br><br>
<span style="margin-left:25px"></span>当r]]a的时候，表达式可以化简为：
<br><br>
<span style="margin-left:25px"></span>(3.6)
<br><br>
<span style="margin-left:25px"></span>由上式可知，在r]]a时，，磁感应强度的衰减与距离r3成正比。
<br><br>
<span style="margin-left:25px"></span>其关系如图3-7所示：图3- 7磁感应强度与距离的关系
<br><br>
<span style="margin-left:25px"></span>由上图可知，从线圈中心到一定距离的磁场强度差不多是变化很小，然后迅速衰落。
<br><br>
<span style="margin-left:25px"></span>这就意味着: 对于手术器械管理系统阅读器来说，可识别距离都会对应着一个最佳的天线边长a。我们来做如下的推导计算，在式3.4中，将B对a求导得出以下等式：(3.7)
<br><br>
<span style="margin-left:25px"></span>并且令可以计算得出 B具有极大值时的条件为，由此得出，手术器械管理系统天线的最佳边长值等于最大期望阅读作用距离的倍，
<br><br>
<span style="margin-left:25px"></span>其中的正负号表示天线产生的磁感应强度在垂直于线圈轴的两个传播方向。3.3.4天线具体分布和形状
<br><br>
<span style="margin-left:25px"></span>手术器械管理系统天线总共有三组天线组成：
<br><br>
<span style="margin-left:25px"></span>登记录入天线、回收桶天线和扫描天线。该手术器械管理系统的登记录入天线获取未使用的无菌纱布部分和扫描天线扫描残留纱布分布都采用的是，单组圆形或者方形线圈天线。回收桶天线为确保手术器械中的 RFID标签，不管以任何角度，认识姿态，摆放在桶内的任何位置，都能被读取到，所以回收桶四周布置了三组线圈天线，实现对纱布回收桶全方位，无死角的覆盖，达到回收桶中没有盲区的效果。回收桶天线效果图如图3-8所示。图3-8 回收桶天线效果图
<br><br>
<span style="margin-left:25px"></span>3.4工控机概述与应用介绍
<br><br>
<span style="margin-left:25px"></span>3.4.1工控机的概念
<br><br>
<span style="margin-left:25px"></span>工控机（Industrial Personal Computer，IPC）即工业控制计算机，是指对工业生产过程及其机电设备、工艺装备进行测量与控制用的计算机。
<br><br>
<span style="margin-left:25px"></span>工控机通俗地说就是专门为工业现场而设计的计算机。工控机如图3-9所示。图3-9 工控机图
<br><br>
<span style="margin-left:25px"></span>工业控制计算机是工业自动化和信息产业基础设备的核心。
<br><br>
<span style="margin-left:25px"></span>传统意义上，将用于工业生产过程的测量、控制和管理的计算机统称为工业控制计算机，包括计算机和过程输入与输出通道二部分。但今天工业控制计算机的内涵已经远不止这些，其应用范围也已经远远超出工业过程控制。因此，工业控制计算机是应用在国民经济发展和国防建设的各个领域、具有恶劣环境适应能力、能长期稳定工作的加固的增强型个人计算机（ PC），因此也简称工控机。工控机之所以大受欢迎，其根本原因在于PC的开放性。
<br><br>
<span style="margin-left:25px"></span>其硬件和软件资源极其丰富，并且为工程技术人员和广大用户所熟悉。基于PC的控制系统，所以20%以上的增长速率，并且硬件成为DCS，PLC未来的参照物。3.4.2工控机的特点
<br><br>
<span style="margin-left:25px"></span>工控机是一种加固的增强型个人计算机，它可以作为一个工业控制器在工业环境中可靠运行。
<br><br>
<span style="margin-left:25px"></span>早在20世纪80年代初期，美国AD公司就推出了类似工控机的MAC150工控机，随后美国IBM公司正式推出工业个人计算机IBM7532。由于工控机的性能可靠、软件丰富、价格低廉，在控制系统中异军突起，后来居上，应用日趋广泛。目前，工控机已被广泛引用通信、工业控制现场、路桥收费、医疗、环保及人们生活的方方面面。工控机是根据工业生产的特点和要求而设计的电子计算机，它应用于工业生产中，实现各种控制目的、生产过程和调度管理自动化，
<br><br>
<span style="margin-left:25px"></span>已达到优质、实时、高效、低耗、安全、可靠、减轻劳动强度、改善工作环境的目的，它是自动化仪表的重要分支，也是电子计算机的重要分支。它主要用于工业过程测量、控制、数据采集等工作。而工业现场一般具有强烈震动灰尘多、电磁场力干扰等特点，且一般工厂均是连续作业，即一年中一般没有休息。因此，工控机与普通计算机相比具有以下特点：可靠性高。
<br><br>
<span style="margin-left:25px"></span>工控机通常用于控制不间断的声场过程，在运行期间不允许停机检修，一旦发生故障将会导致质量事故，甚至生产事故，因此要求工控机具有很高的可靠性。实时性好。
<br><br>
<span style="margin-left:25px"></span>工控机对生产过程进行实时控制与监测，因此要求它必须实时地响应控制对象各种参数的变化。环境适应性强，工业现场环境恶劣，电磁干扰严重，供电系统也常受大负荷设备启停干扰，因此要求工控机具有很强的环境适应能力。
<br><br>
<span style="margin-left:25px"></span>系统扩展性好。
<br><br>
<span style="margin-left:25px"></span>随着工厂自动化水平的提高，控制规模也在不断扩大，因此要求工控机具有灵活的扩展性。软硬件兼容性。
<br><br>
<span style="margin-left:25px"></span>能同时利用ISA和PCI及PICMG资源，并支持各种操作系统，多种编程语言，多任务操作系统，充分利用商用PC所积累的软、硬件资源。3.4.3工控机的应用
<br><br>
<span style="margin-left:25px"></span>随着铁路多次提速，原来应用在车站计算机连锁系统、行车调度监督系统以及铁路红外热轴探测系统上，
<br><br>
<span style="margin-left:25px"></span>现在已经开始用新一代 Compact PCI总线和 PXI总线工控机控制;由于电力紧缺而正在加快建设的发电厂和电网系统，需要大量的新一代工控机产品来实现电力系统综合自动化;正在迅速发展的智能交通系统需要新一代工控机技术;纺织工业制造业、食品加工、石油化工行业、车载信息系统等需要采用新一代工控机技术。海军舰载测控设备、陆军车载武器控制系统和指挥系统、新型的飞行模拟教练系统等需要高性能的新一代工控机;航空和航天器地面测控设备、雷达识别和电子对抗系统需要新一代工控机技术;核电站的核聚变低杂波数据采集与控制系统、大专院校的虚拟仪器教学实验系统、汽车功能测试性能测试系统、防洪数字化大坝在线监测系统等需要新一代工控机技术;下一代的网络设备、电信核心和边缘设备、数据通信设备、计算机电话集成( CTD系统和增值服务业务需要 Compact PCI、 PICMG2.16及 ATCA等新一代工控机技术。手术器械管理系统正是在这样的背景下考虑到工控机的可靠性高、实时性好、环境适应性强等优点，
<br><br>
<span style="margin-left:25px"></span>决定在系统控制处采用工控机作为控制软件的安装硬件，来实时可靠地控制整个手术器械管理系统。3.5本章小结
<br><br>
<span style="margin-left:25px"></span>本章在第一节根据系统的开发流程从系统需求分析开始介绍了手术器械管理系统需要实现的效果和功能，然后提出了手术器械管理系统的理论整体框图和规划，
<br><br>
<span style="margin-left:25px"></span>最后具体介绍了理论框图具体实现的方法和用到的相关技术。第二节介绍了上一节提及手术器械内嵌的RFID标签，从手术器械管理系统的实际需求的参数角度来解释了选择ISO15693RFID标签的原因。第三节介绍了手术器械管理系统天线相关的设计和原理。第四节介绍了手术器械管理系统涉及到的工控机的概念、优点和应用场景，变相地解释了手术器械管理系统选择工控机的原因和优势。第四章系统硬件部分
<br><br>
<span style="margin-left:25px"></span>上一章介绍了系统的整体结构和各个组成部分，本章着重介绍手术器械管理系统的硬件电路部分。
<br><br>
<span style="margin-left:25px"></span>系统的硬件电路主要是RFID阅读器的三个部分：射频前端模块、FPGA编解码模块和MCU逻辑控制模块。MCU逻辑控制模块负责RFID阅读器的工作逻辑控制和将采集的信息上传至上位机程序；FPGA编解码模块依据ISO15693协议实现MCU和射频前端电路之间通信的编码和解码；射频前端电路对发射信号进行调制和放大，对接收信号进行整形滤波和解调。本章准备从阅读器的射频前端电路设计、FPGA编解码电路设计和MCU逻辑控制电路设计三部分来介绍。4.1 射频前端电路设计
<br><br>
<span style="margin-left:25px"></span>射频前段电路分为发射和接收电路两部分，均采用分立元件设计，使得硬件电路更加简单、成本更低而且性能更稳定。
<br><br>
<span style="margin-left:25px"></span>4.1.1 发射电路设计
<br><br>
<span style="margin-left:25px"></span>在发射电路设计中，射频前端发射电路的主要功能表现如下：
<br><br>
<span style="margin-left:25px"></span>首先由本地振荡器产生一个频率为13.56 MHz的载波信号，本设计中采用的是稳定性好的石英晶体振荡器，接着和已经调制好的基带信号通过调制电路进行 ASK调制，为了能够保证天线对于发射功率的要求，需要将信号通过功率放大电路进行放大，接着再将信号通过第二级功率放大电路进行二次放大，然后再送到天线，天线的任务就是将信息通过电磁波向电子标签发射，以确保电子标签的正常工作。前端发射电路的发射通道主要由以下几部分构成：
<br><br>
<span style="margin-left:25px"></span>编码好的基带信号，本地振荡器，二级功率放大器和天线。其主要的结构图如图4-1所示：图4-1发射电路构成图
<br><br>
<span style="margin-left:25px"></span>4.1.2 接收电路设计
<br><br>
<span style="margin-left:25px"></span>上一节介绍了射频前端发射电路，这小节介绍射频前端接收电路，接收电路利用 AD8616芯片外接滤波器构成的两级放大滤波电路，
<br><br>
<span style="margin-left:25px"></span>将13.56 MHz的载波信号滤除，提取出副载波信号，然后利用 MAX9142双路比较器对提取的副载波信号进行规整和优化。其中AD8616芯片具有低失调、低噪声、极低的输入偏置电流和高速度的特性，配合滤波器可以完整高效的提取出副载波信号。双路比较器MAX9142具有低功耗、高速度、满摆幅特点可以快速稳定的对信号进行整形和优化。接收电路部分重要电路如图4-2所示。图4-2 接收电路部分电路
<br><br>
<span style="margin-left:25px"></span>4.2 FPGA编解码电路设计
<br><br>
<span style="margin-left:25px"></span> FPGA编解码电路负责将 MCU传过来的数据编码成 ISO15693协议中的4取1码发往射频前端电路，
<br><br>
<span style="margin-left:25px"></span>将接收到的射频前端电路的数据解码成二进制数据，传给 MCU。整个系统中FPGA实现编码和解码的功能。4.2.1 FPGA原理简述
<br><br>
<span style="margin-left:25px"></span>FPGA是现场可编程门阵列的简称，是超大规模集成电路与计算机辅助设计技术发展的结果。
<br><br>
<span style="margin-left:25px"></span>这些可编辑元件，用来存储逻辑数据或作为电子开关。常用的可编程元件分为以下四种类型：熔丝型开关、反熔丝型开关、浮栅编程元件、基于SRAM的编程元件。FPGAs 就是可再编程芯片。使用预建的逻辑块和可编程路由资源，你根本不需要拿起面包板或者烙铁就可以使这些芯片具有特定的硬件功能。你可以在软件中开发数位运算系统并将其编译到配置文件或比特流，其包含元件接线的相关信息。此外，当你编译不同的配置电路时，完全可重设的FPGA可立即接受一个全新的设置。高级设计工具的兴起，不仅改变了FPGA编程的规则，而且新技术可以将图形化代码或者C代码转变为数字硬件电路。 FPGA的集成度相当高，最多可达到数千万系统门的集成度，可以完成相当复杂的时序和组合逻辑电路的功能，适合于高集成度的高端数字逻辑电路的设计。FPGA 技术的5大优点 :
<br><br>
<span style="margin-left:25px"></span>a.效能 依靠硬件并行的优点，FPGA 可以突破依序执行的固定运算，以此可以在每个时钟周期内完成更多的操作，从而超越了数字信号处理器 (DSP) 的计算功能。
<br><br>
<span style="margin-left:25px"></span>BDTI著名分析师和基准测试公司，公布的基准显示FPGA可以实现比数字信号处理器处理的一些应用程序多很多倍的处理能力。2个输入输出的I/O在硬件层上可缩短回应时间并且可以特定某些功能，以此更符合应用需求。b.上市时间 针对上市时间而言，FPGA 技术具有灵活和快速成型能力。
<br><br>
<span style="margin-left:25px"></span>使用者不需经过定制ASIC的繁琐冗长的流程设计，即可在硬件中测试或验证某个想法。您只需要几小时而不是几周，就可以在FPGA设计上实现增量变化和替换。现成的商用(COTS) 硬件可以搭配使用不同种类的 I/O接口，然后连接至使用者设定的 FPGA 晶片。以此可见 FPGA 技术大大缩短了设计流程的时间，提高了很大的效率。c.成本 定制的 ASIC 设计的一次性工程花费，远远超过基于FPGA 硬件解决方案的费用。
<br><br>
<span style="margin-left:25px"></span> ASIC的大型初始投资，可简单认为原始制造商每年所出货的数千组晶片，但是许多末端使用者更需要定制的硬件功能，以用于开发过程中的数十百组系统。而可编程芯片的特性，代表低成本的制造，或长时间的装配。由于系统需求功能随时都在变化，因此若与 ASIC巨大的修改费用相比较的话，可以看出FPGA 设计的成本实在很少很少了。d.可靠性 而软件工具提供的编程环境，FPGA电路是一个真实的硬实施程序。
<br><br>
<span style="margin-left:25px"></span>处理器的系统往往涉及多个抽象的层次来帮助安排任务，并在多个进程共享资源。驱动层控制硬件资源，而操作系统则管理内存与处理器带宽。对于任何给定的处理器核心，一次只有一条指令可以执行；而处理器的系统则可连续处理重要操作。FPGA 不需使用操作系统，并将产生问题的机率降至最低，以平行执行的方式和准确的硬件致力于每一个任务。e.长期维护 如稍早所提，FPGA 晶片有即时升级特性，不需如 ASIC 重新设计的时间与费用。
<br><br>
<span style="margin-left:25px"></span>举例来说，数字通信协议，例如:规格可随时间而改变，而 ASIC 的接口却可能产生维护与向下相容的问题。FPGA 具有可重设性，可随时因未来的需要而进行修改。当产品或系统趋于成熟时，不需耗时重新设计或修改机板配置，即可提升相关功能。FPGA 的设计过程是利用EDA开发软件和编程工具对器件进行设计的过程。
<br><br>
<span style="margin-left:25px"></span>其中包括：设计准备、设计输入、设计处理、器件编程、功能仿真、时序仿真、器件测试等七个部分。4.2.2 编解码电路的Verilog设计
<br><br>
<span style="margin-left:25px"></span>编解码逻辑的设计主要是由一个状态机来控制的，此状态机采用三段式状态机，
<br><br>
<span style="margin-left:25px"></span>表面上代码虽然结构复杂，但是可以使有限状态机做到同步寄存器输出，消除了组合逻辑输出不稳定和毛刺的问题，更有利于时序路径的分组，利于在 FPGA上的综合与布局布线。状态机图如图4-3所示。图4-3 编解码电路状态机图
<br><br>
<span style="margin-left:25px"></span>此状态机总共有个七个状态：
<br><br>
<span style="margin-left:25px"></span>STATE_IDLE4’b00_00初始状态
<br><br>
<span style="margin-left:25px"></span>STATE_CODER_BGN_DLY4’b01_00编码开始状态
<br><br>
<span style="margin-left:25px"></span>STATE_CODER_SOF4’b01_01编码SOF状态
<br><br>
<span style="margin-left:25px"></span>STATE_CODER_2BIT4’b01_10编码数据状态
<br><br>
<span style="margin-left:25px"></span>STATE_CODER_EOF4’b01_11编码EOF状态
<br><br>
<span style="margin-left:25px"></span>STATE_DECODER_SOF 4’b10_00解码SOF状态
<br><br>
<span style="margin-left:25px"></span>STATE_DECODER_4BIT4’b10_01解码数据状态
<br><br>
<span style="margin-left:25px"></span>状态机的跳转Verilog程序如下：
<br><br>
<span style="margin-left:25px"></span>always @(*)
<br><br>
<span style="margin-left:25px"></span>case(state)
<br><br>
<span style="margin-left:25px"></span>`STATE_IDLE:
<br><br>
<span style="margin-left:25px"></span>state_next=Coder_en_sync ? `STATE_CODER_BGN_DLY : `STATE_DECODER_SOF;`STATE_CODER_BGN_DLY:
<br><br>
<span style="margin-left:25px"></span>state_next = `STATE_CODER_SOF;
<br><br>
<span style="margin-left:25px"></span>`STATE_CODER_SOF:
<br><br>
<span style="margin-left:25px"></span>state_next = `STATE_CODER_2BIT;
<br><br>
<span style="margin-left:25px"></span>`STATE_CODER_2BIT:
<br><br>
<span style="margin-left:25px"></span>state_next = `STATE_CODER_EOF;
<br><br>
<span style="margin-left:25px"></span>`STATE_CODER_EOF:
<br><br>
<span style="margin-left:25px"></span>state_next = `STATE_IDLE;
<br><br>
<span style="margin-left:25px"></span>`STATE_DECODER_SOF:
<br><br>
<span style="margin-left:25px"></span>state_next = sof_found?
<br><br>
<span style="margin-left:25px"></span> `STATE_DECODER_4BIT : `STATE_IDLE;`STATE_DECODER_4BIT:
<br><br>
<span style="margin-left:25px"></span>state_next = `STATE_IDLE;
<br><br>
<span style="margin-left:25px"></span>default:
<br><br>
<span style="margin-left:25px"></span>state_next = `STATE_IDLE;
<br><br>
<span style="margin-left:25px"></span>endcase
<br><br>
<span style="margin-left:25px"></span>因为整个FPGA编解码模块是半双工的，当编码时就不能解码，所以编解码放在一个状态机中，并通过Coder_en_sync来做指示。
<br><br>
<span style="margin-left:25px"></span>编码部分主要的Verilog程序如下：
<br><br>
<span style="margin-left:25px"></span>always @(negedge Clk)//编码输出
<br><br>
<span style="margin-left:25px"></span>if(rst_sync) begin
<br><br>
<span style="margin-left:25px"></span>Code_out [= #1 1’b1;
<br><br>
<span style="margin-left:25px"></span>end
<br><br>
<span style="margin-left:25px"></span>elseif(state_cnt[6:
<br><br>
<span style="margin-left:25px"></span>0] == 7’b111_1111) begincase(state)
<br><br>
<span style="margin-left:25px"></span>`STATE_CODER_BGN_DLY:
<br><br>
<span style="margin-left:25px"></span>Code_out [= #1 1’b1;`STATE_CODER_SOF:
<br><br>
<span style="margin-left:25px"></span>if(state_cnt[9:7] == 3’b111 || state_cnt[9:7] == 3’b010)Code_out [= #1 1’b0;
<br><br>
<span style="margin-left:25px"></span>else
<br><br>
<span style="margin-left:25px"></span>Code_out [= #1 1’b1;
<br><br>
<span style="margin-left:25px"></span>`STATE_CODER_2BIT:
<br><br>
<span style="margin-left:25px"></span>if(state_cnt[9:7]== {code_data_convert，1’b0})Code_out [= #1 1’b0;
<br><br>
<span style="margin-left:25px"></span>else
<br><br>
<span style="margin-left:25px"></span>Code_out [= #1 1’b1;
<br><br>
<span style="margin-left:25px"></span>`STATE_CODER_EOF:
<br><br>
<span style="margin-left:25px"></span>if(state_cnt[9:7] == 3’b001)Code_out [= #1 1’b0;
<br><br>
<span style="margin-left:25px"></span>else
<br><br>
<span style="margin-left:25px"></span>Code_out [= #1 1’b1;
<br><br>
<span style="margin-left:25px"></span>endcase
<br><br>
<span style="margin-left:25px"></span>end
<br><br>
<span style="margin-left:25px"></span>主要实现的功能是将二进制数据编码成ISO15693协议规定的四选一码，并在数据的开头和结尾分别加上SOF和EOF的码子。
<br><br>
<span style="margin-left:25px"></span>解码部分的主要Verilog代码如下：
<br><br>
<span style="margin-left:25px"></span>always @(negedge Clk)
<br><br>
<span style="margin-left:25px"></span>if(rst_sync) begin
<br><br>
<span style="margin-left:25px"></span>bit_1st_half [= #1 1’b0;
<br><br>
<span style="margin-left:25px"></span>bit_2nd_half [= #1 1’b0;
<br><br>
<span style="margin-left:25px"></span>end
<br><br>
<span style="margin-left:25px"></span>elseif(bit_en) begin
<br><br>
<span style="margin-left:25px"></span>if(state_cnt[10]) begin
<br><br>
<span style="margin-left:25px"></span>bit_1st_half [= #1 ck32_cnt_threshould;
<br><br>
<span style="margin-left:25px"></span>end
<br><br>
<span style="margin-left:25px"></span>else begin
<br><br>
<span style="margin-left:25px"></span>bit_2nd_half [= #1 ck32_cnt_threshould;
<br><br>
<span style="margin-left:25px"></span>end
<br><br>
<span style="margin-left:25px"></span>end
<br><br>
<span style="margin-left:25px"></span>regbit_value;
<br><br>
<span style="margin-left:25px"></span>regbit_err;
<br><br>
<span style="margin-left:25px"></span>always @(*)
<br><br>
<span style="margin-left:25px"></span>case({bit_1st_half， bit_2nd_half})
<br><br>
<span style="margin-left:25px"></span>2’b10:
<br><br>
<span style="margin-left:25px"></span>beginbit_value = 1’b0;
<br><br>
<span style="margin-left:25px"></span>bit_err= 1’b0;
<br><br>
<span style="margin-left:25px"></span>end
<br><br>
<span style="margin-left:25px"></span>2’b01:
<br><br>
<span style="margin-left:25px"></span>beginbit_value = 1’b1;
<br><br>
<span style="margin-left:25px"></span>bit_err= 1’b0;
<br><br>
<span style="margin-left:25px"></span>end
<br><br>
<span style="margin-left:25px"></span>2’b00，
<br><br>
<span style="margin-left:25px"></span>2’b11:
<br><br>
<span style="margin-left:25px"></span>beginbit_value = 1’b0;
<br><br>
<span style="margin-left:25px"></span>bit_err= 1’b1;
<br><br>
<span style="margin-left:25px"></span>end
<br><br>
<span style="margin-left:25px"></span>endcase
<br><br>
<span style="margin-left:25px"></span>主要实现的功能是将前端电路接收的曼切斯特码解码成二进制数据，根据曼切斯特码的特点下降沿为零，
<br><br>
<span style="margin-left:25px"></span>上升沿为一的特点，将接收的载波分成两部分检测，先高后低就是0，先低后高就是1，其余11或者00都置 bit_ err=1报错。4.2.3 编解码电路的软件仿真
<br><br>
<span style="margin-left:25px"></span>编解码逻辑电路设计的仿真分析分成两部分；
<br><br>
<span style="margin-left:25px"></span>编码和解码。此部分借助ModelSim时序仿真软件进行仿真分析，分析Verilog的设计效果。图4-4编码电路的时序仿真图
<br><br>
<span style="margin-left:25px"></span>编码电路部分的时序仿真如图4-4所示，clk是13.56Mhz的时钟信号；
<br><br>
<span style="margin-left:25px"></span>rst是FPGA程序的复位信号；coder_en是编码使能信号；coder_in是接收MCU传入数据的端口；D10_100 是ISO15693中10%和100%两种不同调制，本系统选用的100%调制；Code_out_D100是100%调制的编码输出；Clk_coder是产生的周期时钟信号用于与MCU同步接收MCU 的传入数据；state[3:0]是整个编解码电路的状态机的状态。从上面的时序波形可以清楚的看到当 coder_ en被置高后产生的编码使能信号使得状态机先进入 STATE_ CODER_ BGN_ DLY状态进入编码开始状态，然后进入 STATE_ CODER_ SOF状态在编码数据前加上 SOF码，再进入 STATE_ CODER_2 BIT状态进行四选一的编码，整个数据的编码都在 STATE_ CODER_2 BIT状态中进行，最后进入 STATE_ CODER_ EOF状态在数据的末尾加上 EOF码，从而完成整个编码过程。最后对比输入的数据与编码后的数据是一致的，而且整个过程状态机的跳转也是正确的，可以判断编码电路的设计时可行的。图4-5解码电路的时序仿真图
<br><br>
<span style="margin-left:25px"></span>编码电路部分的时序仿真图如图4-5所示，clk是13.56Mhz的时钟信号；
<br><br>
<span style="margin-left:25px"></span>Main_in是射频前端电路返回的曼切斯特码数据；rst是FPGA程序的复位信号；Decoder_en是编码使能信号；NRZ是向MCU发送解码后数据的端口；Clk_decoder是产生的周期时钟信号用于与MCU同步向MCU 的传送数据；state[3:0]是整个编解码电路的状态机的状态。从面的波形仿真可以看出，当解码电路检测到前端电路的 SOF信号后会进入 STATE_ DECODER_ SOF状态，并随后进入 STATE_ DECODER_4 BIT状态同时将 Decoder_ en使能信号置高，通知 MCU接收解码后的数据，延迟一段时间产生 Clk_ decoder时钟信号来向 MCU传递解码后的数据，整个解码过程都在状态机的 STATE_ DECODER_4 BIT状态中进行。按照以上分析与一开始的解码设计时一样的，完成了设计任务。4.3 MCU逻辑控制电路设计
<br><br>
<span style="margin-left:25px"></span>MCU逻辑控制电路主要负责将通过串口接收上位机传来的操作命令，解析后转成对应的ISO15693协议上的通信帧发往FPGA编码；
<br><br>
<span style="margin-left:25px"></span>将FPGA解码好的标签返回数据包装成与上位机通信的协议返回到上位机中。整个系统中起到了逻辑控制和判断的作用。4.3.1 MCU原理简述与系统MCU芯片选型
<br><br>
<span style="margin-left:25px"></span>从字面上来说，单片机一词中的单片是指一个芯片，机是指小型计算机系统。
<br><br>
<span style="margin-left:25px"></span>这个小型计算机系统的功能部件主要包括中央处理单元、程序存储器、随机访问存储器、中断系统、定时器/计数器、外部设备接口模块，以及连接各个功能部件的总线。图4-6 MCU内部结构图
<br><br>
<span style="margin-left:25px"></span>1.中央处理单元
<br><br>
<span style="margin-left:25px"></span>中央处理单元(central processing unit，CPU)是单片机系统的大脑和中枢，它可以完成下面最基本的功能:
<br><br>
<span style="margin-left:25px"></span>（1）与不同地址空间的不同类型存储器交换信息。
<br><br>
<span style="margin-left:25px"></span>通过对存储器的读和写操作.完成CPU和存储器的信息交换过程。(2)执行逻辑和算术指令。
<br><br>
<span style="margin-left:25px"></span>基本和常用的指令包括加/减运算、逻辑按位或运算、逻辑按位与运算、逻辑按位异或运算、移位运算等。更具体地说，CPU是由一些更小的子系统构成。这些重要的子系统包括:1)程序计数器
<br><br>
<span style="margin-left:25px"></span>PC ( program counter)指向保存将要执行的下一条程序指令的存储器地址。
<br><br>
<span style="margin-left:25px"></span>然后，通过读操作，从PC所指向的存储器的地址获取具体的指令内容。指令中包含着操作码和操作数。如果在执行指令的过程中，并不是顺序地执行指令，如遇到跳转指令，那么PC将加载新的所要运行指令的地址，从而从指向存储器新地址的位置继续执行程序。
<br><br>
<span style="margin-left:25px"></span>2)指令译码单元
<br><br>
<span style="margin-left:25px"></span>从实现的本质来说，指令译码单元就是一个复杂的有限自动状态机(finite state machine， FSM)，它用于对来自程序存储器的指令内容进行翻译。
<br><br>
<span style="margin-left:25px"></span>从而确定将要执行的指令，这些指令表示CPU将要执行的逻辑操作行为。实际上，这些逻辑操作行为就是一系列的控制序列。3)算术逻辑单元
<br><br>
<span style="margin-left:25px"></span>ALU(arithmetic logic unit)是CPU中最为重要的核心单元。
<br><br>
<span style="margin-left:25px"></span>通过指令译码单元发出的控制信号，将需要操作的数据从寄存器、存储器中取出，并被送到ALU，然后执行所要求的算术运算或者逻辑运算。4)控制寄存器和状态寄存器组
<br><br>
<span style="margin-left:25px"></span>对于CPU来说，其内部的控制寄存器组用于设置CPU的工作模式;
<br><br>
<span style="margin-left:25px"></span>而状态寄存器组用于反映CPU当前的工作状态，如CPU执行加法运算的过程中，是否出现溢出、进位等。2.程序存储器
<br><br>
<span style="margin-left:25px"></span>程序存储器用于保存将要执行的程序代码。
<br><br>
<span style="margin-left:25px"></span>通常地，程序存储器是非易失性的，即一旦将程序固化到存储器中，除非重新固化程序到存储器中，否则程序将一直保存在存储器中。即使给单片机断电，在下次上电时，原来固化在程序存储器中的程序仍然存在。从工艺来说，大多数单片机的程序存储器采用Flash 工艺，极少数的单片机采用一次可编程（one-time-programmable，OTP）工艺。
<br><br>
<span style="margin-left:25px"></span>当采用Flash工艺时，设计者可以多次修改和固化程序;当采用()TP工艺时一旦程序固化，设计者就再也没有机会修改程序。3.随机访问存储器
<br><br>
<span style="margin-left:25px"></span>RAM(random access memory)存储器保存着在程序中所需要用到的数据。
<br><br>
<span style="margin-left:25px"></span>4.中断系统
<br><br>
<span style="margin-left:25px"></span>中断系统用于CPU对紧急事件的处理。
<br><br>
<span style="margin-left:25px"></span>当 CPU正在执行当前的程序时，如果外部设备发出了紧急事件的请求，也就是通常所说的中断请求信号时，如果 CPU允许立即处理当前紧急事件，则打断当前正在执行的程序，从而对紧急事件进行处理，也就是通常所说的用于处理紧急事件的程序，即中断服务程序。当CPU开始对外部紧急事件进行处理时，会通过中断系统通知外部设备CPU已经开始处理紧急事件。
<br><br>
<span style="margin-left:25px"></span>这样，外部设备会做出相应的判断。5.定时器/计数器
<br><br>
<span style="margin-left:25px"></span>在单片机中，定时器/计数器单元是一个最基本的功能单元。
<br><br>
<span style="margin-left:25px"></span>通过这个单元。可以对不同事件进行同步。典型的，当定时器中的计数值到达预先设置的初值时，就会产生定时器中断信号。通过这个信号，就可以同步其他设备。6.外部设备接口模块
<br><br>
<span style="margin-left:25px"></span>不同单片机厂商所提供的外部接口模块也不尽相同。
<br><br>
<span style="margin-left:25px"></span>但是，基本上都提供了通用IO(general purpose input and output，GPIO)和RS-232接口等。7.总线
<br><br>
<span style="margin-left:25px"></span>总线是一组相关逻辑信号的集合。
<br><br>
<span style="margin-left:25px"></span>目前大多数计算机系统都是基于总线的结构，总线包括控制总线、地址总线和数据总线。对于单片机系统来说，总线分为内部总线和外部总线。
<br><br>
<span style="margin-left:25px"></span>其中:(1)内部总线用于连接芯片内各个模块单元。
<br><br>
<span style="margin-left:25px"></span>(2)外部总线用于将外设连接到单片机上。
<br><br>
<span style="margin-left:25px"></span>选择一款单片机，选型的原则包括:
<br><br>
<span style="margin-left:25px"></span>(1)在产品交付后，是否需要修改设计，即将来是否需要使用应用在线编程的产品升级方法。
<br><br>
<span style="margin-left:25px"></span>(2)在设计阶段对系统进行调试和仿真时所需要的调试和仿真环境。
<br><br>
<span style="margin-left:25px"></span>(3)单片机的价格成本。
<br><br>
<span style="margin-left:25px"></span>(4)单片机的工作环境要求。
<br><br>
<span style="margin-left:25px"></span>(5)单片机的封装形式。
<br><br>
<span style="margin-left:25px"></span>(6)单片机的工作频率。
<br><br>
<span style="margin-left:25px"></span>(7)单片机内的程序存储器容量。
<br><br>
<span style="margin-left:25px"></span>(8)单片机的片内RAM容量。
<br><br>
<span style="margin-left:25px"></span>(9)在满足上述要求的前提下，优先选用片内外设资源丰富的单片机。
<br><br>
<span style="margin-left:25px"></span>根据实际手术器械管理系统的阅读器工作需求，从市场中挑选了 STC的一款性价比较高的 IAP15 W4 K61 S4单片机，
<br><br>
<span style="margin-left:25px"></span>具有30 MHz的最大处理器频率，保证其能够快速的完成 ISO15693协议中的抗冲突算法，实现快速准确识别多张标签的要求。4.3.2MCU电路设计
<br><br>
<span style="margin-left:25px"></span>单片机通过MAX232串口芯片实现与工控机串口通信。
<br><br>
<span style="margin-left:25px"></span>在与 FPGA编解码模块通信时利用单片机自带的外部中断机制，将单片机中断设置为下降沿触发， FPGA设计成上升沿触发，实现一个方波信号传递一位数据的快速稳定的通信方法。单片机采用 P1.2、 P1.3、 P1.4、 P1.5、 P3.5、 P3.2、 P3.3这7个端口与 FPGA完成通信，其中 P3.2和 P3.3为单片机的外部中断0和外部中断1引脚。单片机考虑到稳定性和可靠性采用外部24MHz晶振。各个引脚的意义如下：SW1SW4：
<br><br>
<span style="margin-left:25px"></span>用于切换三组天线的标志coder_en:
<br><br>
<span style="margin-left:25px"></span>给FPGA的编码使能信号code_out:
<br><br>
<span style="margin-left:25px"></span>给FPGA发需要编码的数据口FPGA_rst:
<br><br>
<span style="margin-left:25px"></span> FPGA复位信号decode_en:
<br><br>
<span style="margin-left:25px"></span>FPGA给MCU的解码使能信号NRZ:
<br><br>
<span style="margin-left:25px"></span> FPGA将解码后的数据返回至MCUclk_coder:
<br><br>
<span style="margin-left:25px"></span> FPGA编码时，MCU向FPGA发数据的同步信号clk_decoder:
<br><br>
<span style="margin-left:25px"></span>FPGA解码时往MCU传数据的同步信号MCU电路图如图4-7所示。
<br><br>
<span style="margin-left:25px"></span>图4-7 MCU电路图
<br><br>
<span style="margin-left:25px"></span>4.3.3MCU外围电路设计
<br><br>
<span style="margin-left:25px"></span>MCU外围电路主要是串口电路。
<br><br>
<span style="margin-left:25px"></span>手术器械管理系统的阅读器需要与上位机软件进行数据通信，采用最常用的串口作为通信接口，具有稳定、快速、设计简单等优点。串口电路采用 MAX232芯片作为收发器，其专用低压差发送器输出级在供电电压为3.0 v至5.5 v之间时，利用双电荷泵实现真正的 RS-232性能。电荷泵起高压仅需四个0.1uf的外部小尺寸电荷泵电容。MAX232在最差工作条件下，可以确保达到120kbps数据速率，同时输出电平能够保持RS-232输出电平。 MAX232据有二路接收和二路驱动器，提供1 A关断模式，有效降低功耗，
<br><br>
<span style="margin-left:25px"></span>在关断模式下接收器保持有效状态，对外部设备进行检测，仅消耗1 A电源电流，为测试仪与上位机之间数据传输提供了稳定的通道。串口电路如图4-8所示。图4-8 串口电路
<br><br>
<span style="margin-left:25px"></span>4.4 MCU与FPGA编解码电路接口设计
<br><br>
<span style="margin-left:25px"></span>单片机采用 P1.2、 P1.3、 P1.4、 P1.5、 P3.5、 P3.2、 P3.3这7个端口与 FPGA完成通信，
<br><br>
<span style="margin-left:25px"></span>其中 P3.2和 P3.3为单片机的外部中断0和外部中断1引脚，并设成下降沿触发。P1.2 coder_en:
<br><br>
<span style="margin-left:25px"></span> 给FPGA的编码使能信号P1.3code_out:
<br><br>
<span style="margin-left:25px"></span> 给FPGA发需要编码的数据口P1.5FPGA_rst:
<br><br>
<span style="margin-left:25px"></span> FPGA复位信号P3.5 decode_en:
<br><br>
<span style="margin-left:25px"></span>FPGA给MCU的解码使能信号P1.4 NRZ:
<br><br>
<span style="margin-left:25px"></span> FPGA将解码后的数据返回至MCUP3.2clk_coder:
<br><br>
<span style="margin-left:25px"></span> FPGA编码时，MCU向FPGA发数据的同步信号P3.3 clk_decoder:
<br><br>
<span style="margin-left:25px"></span>FPGA解码时往MCU传数据的同步信号编码MCU向FPGA传递数据的过程：
<br><br>
<span style="margin-left:25px"></span>图4-9 MCU向FPGA传递数据
<br><br>
<span style="margin-left:25px"></span>单片机向 FPGA发送 FPGA_ rst复位信号，接着将 coder_ en信号置高表示 FPGA可以开始进行编码， FPGA产生 clk_ coder周期信号，
<br><br>
<span style="margin-left:25px"></span>单片机检测到 clk_ coder信号的下降沿时向 code_ out口传送数据， FPGA在 clk_ coder信号的上升沿时接收 code_ out口的数据，一个 clk_ coder信号传递1 bit数据。MCU数据传递结束后将coder_en置低，数据传递结束。解码FPGA向MCU传递数据的过程：
<br><br>
<span style="margin-left:25px"></span>图4-10 FPGA向MCU传递数据
<br><br>
<span style="margin-left:25px"></span>当 MCU向 FPGA数据传完之后，向 FPGA发送一个 FPGA_ rst复位信号， FPGA开始对射频前端返回的数据进行 SFO帧开头检测，
<br><br>
<span style="margin-left:25px"></span>当检测到 SFO后将 decode_ en使能信号置高，告诉 MCU准备接收解码后的数据，并同时产生 clk_ deocde的周期信号用来传递解调后的数据，在 clk_ deocde的上升沿时 FPGA给 NRZ口置数，在 clk_ deocde的下降沿时 MCU接收 NRZ的数据，一个 clk_ coder信号传递1 bit数据。直到FPGA检测到EOF帧结束标志，将decode_en置低，结束数据传输。4.5本章小结
<br><br>
<span style="margin-left:25px"></span>本章着重介绍了手术器械管理系统的硬件电路部分的设计，第一节大体分析了射频前端发射和接收部分的设计思想和思路；
<br><br>
<span style="margin-left:25px"></span>第二节着重分析了编解码电路FPGA的开发设计的过程和Verilog程序，并根据编码和解码部分的时序波形仿真图进行了分析介绍；第三章重点介绍了MCU理论和相应的本系统的电路设计和外围电路的组成；第四节分析了MCU电路和FPGA电路两部分的数据通信方式和设计思想。总体来说本章对手术器械管理系统的硬件介绍是非常全面到位的。第五章系统软件部分
<br><br>
<span style="margin-left:25px"></span>系统软件设计采用模块化的思想设计程序，设计时注意各个模块之间的数据传输方式。
<br><br>
<span style="margin-left:25px"></span>MCU控制软件是基于单片机IAP15W4K61S4采用C语言设计的，多模块结合使得程序逻辑结构清晰，代码量少。上位机程序设计采用 C++语言基于 Qt Creator图形界面应用程序开发软件开发的，该软件具有成熟的库函数，移植性强，运行环境多样等特点，支持 Linux， Windows等操作系统可以快速简单的开发出友好简洁的交互界面。5.1MCU软件设计
<br><br>
<span style="margin-left:25px"></span>5.1.1 STC单片机软件开发介绍
<br><br>
<span style="margin-left:25px"></span>STC单片机采用C51内核作为单片机CPU内核的，支持汇编语言和C语言两种开发模式。
<br><br>
<span style="margin-left:25px"></span>C语言程序本身不依赖于机器硬件系统，基本上不做修改或仅做简单的修改就将程序从不同的系统移植过来直接使用。
<br><br>
<span style="margin-left:25px"></span>C语言提供了很多数学函数并支持浮点运算，开发效率高，可极大地缩短开放时间，增加程序可读性和可维护性。单片机的C51编程与用汇编编程相比，有如下有点：对单片机的指令系统不要求有任何了解，就可以用C语言直接编程操作单片机。
<br><br>
<span style="margin-left:25px"></span>寄存器分配、不同存储器的寻址及数据类型等细节完全由编译器自动管理。
<br><br>
<span style="margin-left:25px"></span>程序有规范的结构，可分成不同的函数，可使程序机构化。
<br><br>
<span style="margin-left:25px"></span>库中包含许多标准子程序，具有较强的数据处理能力，使用方便。
<br><br>
<span style="margin-left:25px"></span>具有方便的模块编程技术，使已编好的程序很容易移植。
<br><br>
<span style="margin-left:25px"></span>根据以上C语言开发的优点分析，系统开发采用C语言开发。
<br><br>
<span style="margin-left:25px"></span>STC单片机软件开发的流程如下：
<br><br>
<span style="margin-left:25px"></span>1.明确软件需要实现的功能
<br><br>
<span style="margin-left:25px"></span>对于程序设计人员来说，需要完成下面的工作:
<br><br>
<span style="margin-left:25px"></span>（1）了解所提供硬件的性能。
<br><br>
<span style="margin-left:25px"></span>（2）了解STC单片机的软件开发环境Keil uVision。
<br><br>
<span style="margin-left:25px"></span>（3）设计出软件的数据流图和程序流图。
<br><br>
<span style="margin-left:25px"></span>（4）明确程序的概要设计和详细设计方案。
<br><br>
<span style="margin-left:25px"></span>2.
<br><br>
<span style="margin-left:25px"></span> C代码的编写通过Keil uVision软件提供的C语言编辑器和汇编语言编辑器。
<br><br>
<span style="margin-left:25px"></span>3.使用编译器对C代码进行编译
<br><br>
<span style="margin-left:25px"></span>4.使用库管理器生成库文件
<br><br>
<span style="margin-left:25px"></span>当设计中需要使用库时，软件调用库管理器，允许创建一个库，或者添加目标文件到库中，或者从库文件中删除目标文件。
<br><br>
<span style="margin-left:25px"></span>5.使用链接器生成绝对目标模块文件
<br><br>
<span style="margin-left:25px"></span>软件调用Keil uVision提供的链接器/定位器，通过将前面C编泽器创建的目标模块链接在一起来创建一个绝对目标模块。
<br><br>
<span style="margin-left:25px"></span>前面编译器所创建的这些目标模块是可以重新定位的，但不可以直接运行(即使只有一个源模块构成)。这些目标文件必须通过链接器链接在一起，并且转换成一个绝对目标文件。6.使用转换器将绝对目标文件转换成十六进制文件
<br><br>
<span style="margin-left:25px"></span>软件调用Keil uVivion提供的工具，将链接器创建的绝对目标文件转换成Intel格式的十六进制文件.HEX。
<br><br>
<span style="margin-left:25px"></span>7.使用STC-ISP软件将十六进制文件固化到STC单片机中
<br><br>
<span style="margin-left:25px"></span>当上面的硬件和软件设计流程结束后，通过 STC提供的 USB转串口下载线，以及 STC提供的
<br><br>
<span style="margin-left:25px"></span> STC- ISP软件将 HEX文件下载到设计者所选择型号单片机的程序存储器中。5.1.2 MCU软件框架设计
<br><br>
<span style="margin-left:25px"></span>首先，对各个模块初始化和单片机IAP15W4K61S4引脚配置。
<br><br>
<span style="margin-left:25px"></span>当检测到串口中断后，进入串口中断服务程序，根据事先设定的通信协议识别帧头，开始接收数据。接收完成后进行循环冗余检查（CRC）校验，校验正确则将接收完成标志置为正。当主程序检测到接收完成标志位被置为正，对接收的数据进行解析判断，根据接收到的命令向FPGA中发送对应的命令帧。随后接收FPGA中返回的数据帧，进行CRC校验，通过后依据串口通信协议对接收数据进行打包，最后通过串口向上位机返回数据。一次通信完成后，程序回到主程序接收完成标志的检测函数，进行循环检测直到检测到下一次完成标志，进行上面同样的步骤。MCU程序具体流程如图5-1所示。图5-1 MCU程序流程图
<br><br>
<span style="margin-left:25px"></span>5.1.3 MCU核心代码的实现
<br><br>
<span style="margin-left:25px"></span>上一小节介绍了整个MCU程序设计的流程图，整个程序主要由main主程序，myUART串口程序，command命令处理程序和与FPGA通信的程序四个主要部分。
<br><br>
<span style="margin-left:25px"></span>main主函数程序进行一些端口和寄存器的初始化，并包含一个while（）死循环，用来让单片机一直处于进行工作状态。
<br><br>
<span style="margin-left:25px"></span>为了防止程序跑偏，或者在某个环节卡死，为主函数设计一个4s的看门狗程序。主函数的程序如下：void main()
<br><br>
<span style="margin-left:25px"></span>P0M0=0x00;
<br><br>
<span style="margin-left:25px"></span>P0M1=0x00;P1M0=0x00;
<br><br>
<span style="margin-left:25px"></span>P1M1=0x00;P2M0=0x00;
<br><br>
<span style="margin-left:25px"></span> P2M1=0x00;P3M0=0x00;
<br><br>
<span style="margin-left:25px"></span>P3M1=0x00;P5M0=0x00;
<br><br>
<span style="margin-left:25px"></span>P5M1=0x00;//初始化IO口为准双向口模式LED_PORT=0;
<br><br>
<span style="margin-left:25px"></span>SW1_PORT=1;
<br><br>
<span style="margin-left:25px"></span>SW2_PORT=0;
<br><br>
<span style="margin-left:25px"></span>SW3_PORT=0;
<br><br>
<span style="margin-left:25px"></span>SW4_PORT=0;
<br><br>
<span style="margin-left:25px"></span>SW5_PORT=1;
<br><br>
<span style="margin-left:25px"></span>BELL_PORT=0;
<br><br>
<span style="margin-left:25px"></span>POWER_PORT=0;
<br><br>
<span style="margin-left:25px"></span>TEST1_PORT=0;
<br><br>
<span style="margin-left:25px"></span>Uart0_Init() ;
<br><br>
<span style="margin-left:25px"></span>//串口初始化FPGA_Initial();
<br><br>
<span style="margin-left:25px"></span>//FPGA初始化Timer1_init() ;
<br><br>
<span style="margin-left:25px"></span>watchdog_init();
<br><br>
<span style="margin-left:25px"></span> //初始化看门狗EA=1;
<br><br>
<span style="margin-left:25px"></span> //全局中断使能while(1)
<br><br>
<span style="margin-left:25px"></span>command();
<br><br>
<span style="margin-left:25px"></span>LED_cn++;
<br><br>
<span style="margin-left:25px"></span>if(LED_cn]0xb0000)
<br><br>
<span style="margin-left:25px"></span>Led_on(40);
<br><br>
<span style="margin-left:25px"></span>LED_cn=0;
<br><br>
<span style="margin-left:25px"></span>WDT_CONTR=0x37;
<br><br>
<span style="margin-left:25px"></span>//喂看门狗 myUART串口程序主要由接收和发射电路组成，串口使用单片机串口1的工作模式1，
<br><br>
<span style="margin-left:25px"></span>8位 UART，波特率可变，定时器2作为波特率发生器，波特率为115200。具体的寄存器参数设置如下：SCON = 0x50;
<br><br>
<span style="margin-left:25px"></span>//8位数据，可变波特率AUXR |= 0x01;
<br><br>
<span style="margin-left:25px"></span>//串口1选择定时器2为波特率发生器AUXR |= 0x04;
<br><br>
<span style="margin-left:25px"></span>//定时器2时钟为Fosc，即1TT2L = 0xCC;
<br><br>
<span style="margin-left:25px"></span>//设定定时初值T2H = 0xFF;
<br><br>
<span style="margin-left:25px"></span>//设定定时初值AUXR |= 0x10;
<br><br>
<span style="margin-left:25px"></span>//启动定时器2 command命令处理程序在主函数的 while循环函数内，通过一个全局变量 Rev_ flag来判断是否完整的接收了一帧串口数据，
<br><br>
<span style="margin-left:25px"></span>只有当串口函数接收一帧完整的数据才会将 Rev_ flag置为1，这样才会进入 command命令处理程序对这一帧数据进行相应的处理。if(Rev_flag)//表示接收上位机命令结束，开始处理命令；
<br><br>
<span style="margin-left:25px"></span>或等待状态Rev_flag=0;
<br><br>
<span style="margin-left:25px"></span>REN=0;
<br><br>
<span style="margin-left:25px"></span> //禁止串口1接收message_box[4]=UART0_RX_BUF[1];
<br><br>
<span style="margin-left:25px"></span>//天线地址（通道地址）除去0x11、0X22、0x33头的第2位表示通道
<br><br>
<span style="margin-left:25px"></span>POWER_PORT=0;
<br><br>
<span style="margin-left:25px"></span>//RF关闭delay_ms(1);
<br><br>
<span style="margin-left:25px"></span>POWER_PORT=1;
<br><br>
<span style="margin-left:25px"></span>//RF打开delay_ms(2);
<br><br>
<span style="margin-left:25px"></span>switch(UART0_RX_BUF[2])
<br><br>
<span style="margin-left:25px"></span>case 0x01:
<br><br>
<span style="margin-left:25px"></span>anticollision();
<br><br>
<span style="margin-left:25px"></span>break;
<br><br>
<span style="margin-left:25px"></span>case 0x02:
<br><br>
<span style="margin-left:25px"></span>Reset_Select_quiet();
<br><br>
<span style="margin-left:25px"></span> //静默没写break;
<br><br>
<span style="margin-left:25px"></span>default:
<br><br>
<span style="margin-left:25px"></span>message_box[6]=0x90;
<br><br>
<span style="margin-left:25px"></span> //不支持指令response();
<br><br>
<span style="margin-left:25px"></span>break;
<br><br>
<span style="margin-left:25px"></span>POWER_PORT=0;
<br><br>
<span style="margin-left:25px"></span>//RF关闭REN=1;
<br><br>
<span style="margin-left:25px"></span> //打开串口1 MCU与 FPGA通信的程序，主要是通过外部中断0和外部中断1来模拟 SPI的传输方式实现的2个硬件之间同步传输数据，
<br><br>
<span style="margin-left:25px"></span>不直接使用 SPI这样的好处是使得2个硬件之间的数据传递更加简洁，稳定，快速，不受约束（通信过程请参考第四章系统硬件部分的4.4小节 MCU与 FPGA编解码电路接口设计）。外部中断0和中断1都设置为下降沿触发，寄存器设置为：IT1=1; IT0=1;外部中断0负责向FPGA发送数据，每一个中断信号发送1bit，具体代码如下：void INT0() interrupt 0
<br><br>
<span style="margin-left:25px"></span>if((send_data 0x01)==1)
<br><br>
<span style="margin-left:25px"></span>coder_out_PORT=1;
<br><br>
<span style="margin-left:25px"></span>else
<br><br>
<span style="margin-left:25px"></span>coder_out_PORT=0;
<br><br>
<span style="margin-left:25px"></span>send_data=send_data]]1;
<br><br>
<span style="margin-left:25px"></span>int_0++;
<br><br>
<span style="margin-left:25px"></span>外部中断1负责接收FPGA发送的数据，每一个中断信号接收1bit，具体代码如下：
<br><br>
<span style="margin-left:25px"></span>void INT1() interrupt 2
<br><br>
<span style="margin-left:25px"></span>static unsigned char redata=0;
<br><br>
<span style="margin-left:25px"></span>int_1++;
<br><br>
<span style="margin-left:25px"></span>cn1=0;
<br><br>
<span style="margin-left:25px"></span>cn2++;
<br><br>
<span style="margin-left:25px"></span>if(NRZ_PORT)
<br><br>
<span style="margin-left:25px"></span>redata+=0x80;
<br><br>
<span style="margin-left:25px"></span> //从低位开始接收if(int_1==8)
<br><br>
<span style="margin-left:25px"></span>int_1=0;
<br><br>
<span style="margin-left:25px"></span>RXD[length_R++]=redata;
<br><br>
<span style="margin-left:25px"></span>//数据丢到RXD里面暂时存放redata=0;
<br><br>
<span style="margin-left:25px"></span>redata=redata]]1;
<br><br>
<span style="margin-left:25px"></span>5.1.4 标签抗冲突代码实现
<br><br>
<span style="margin-left:25px"></span>抗冲突是ISO15693协议标签的重要功能，及能同时读取场内多张射频标签的特性。
<br><br>
<span style="margin-left:25px"></span>其实现的原理是在标签端和阅读器端都进行特殊处理，本小节将着重介绍阅读器端的抗冲突实现过程。ISO15693协议中介绍的16slot的抗冲突如图5-2所示的步骤如下：
<br><br>
<span style="margin-left:25px"></span>VCD发送一次目录请求，在一帧内，由 EOF结束。
<br><br>
<span style="margin-left:25px"></span>slots的数量是16。VICC 1在 slot 0发送其响应。
<br><br>
<span style="margin-left:25px"></span>它是唯一发送响应的 VICC，因此不会发生冲突，VCD收到它的UID并为其注册。VCD发送一个 EOF，意思是接通到下一 slot。
<br><br>
<span style="margin-left:25px"></span>在 slot 1，两个 VICCs 2和 3同时传输它们的响应，产生一次冲突。
<br><br>
<span style="margin-left:25px"></span>VCD发送一个 EOF，意思是接通至下一个 slot。
<br><br>
<span style="margin-left:25px"></span>在 slot 2，没有 VICC传输响应。
<br><br>
<span style="margin-left:25px"></span>因此 VCD不检测一个 VICC SOF，而是通过发送一个 EOF，接通至下一个 slot。VCD决定发送一个寻址请求（例如一个读块请求）给 VICC 1，其 UID已被正确接收。
<br><br>
<span style="margin-left:25px"></span>所有的 VICCs检测到 SOF，将退出防冲突序列。
<br><br>
<span style="margin-left:25px"></span>它们处理这个请求，因为请求地址是配给 VICC1的，只有 VICC 1可传输其响应。注：
<br><br>
<span style="margin-left:25px"></span>中断防冲突序列的决定权在 VCD。它可以持续发送 EOF，直到遍历至 slot 15，然后发送请求给 VICC 1。其中VICC：标签，VCD：阅读器。图5-2 ISO15693协议中16slot的抗冲突步骤
<br><br>
<span style="margin-left:25px"></span>根据协议的定义和实际的手术器械管理系统的情况设计了一套简化的但效率高的抗冲突实现方法。
<br><br>
<span style="margin-left:25px"></span>结合协议中的抗冲突方法，第一步从 slot0开始发送 Mask值为0 x00（因不足8位补齐8位）， Mask长度为4，如果没有产生冲突（如果有返回接收返回的标签 UID），并发送 EOF接通到下一个 slot（ Mask值为0 x01， Mask长度为4），这样一直下去，直到0 x0 F结束整个抗冲突过程。这个过程中一旦产生冲突在此时Mask值变为0x0Y（Y为产生冲突的slot，Y值：0-15）， Mask长度变为8，及在原来的基础上加长4位进行比较，如果还产生冲突在往上加4位， Mask值为0 x000 Y， Mask值为12，直到没有冲突产生，但最高 Mask长度可以加到16位（考虑到抗冲突过程的时间）。这种抗冲突的方式因为减省了与标签的一部分通信，可以在标签不是很多的情况快速读取（因为手术器械管理系统要求一次读取的标签数在50张左右），这样可以大大提高抗冲突的效率，从而提高了对标签的识别效率。5.2上位机软件设计
<br><br>
<span style="margin-left:25px"></span>上位机程序是整个系统的开始点和结束点，是系统与人的交互点，因此界面不仅要简洁明了，更要保证操作快捷方便。
<br><br>
<span style="margin-left:25px"></span>利用Qt特有的信号与槽的机制使得系统操作者只需点击界面按钮，便可触发对应的操作，完成数据的获取。5.2.1 Qt技术简介
<br><br>
<span style="margin-left:25px"></span>Qt是一个跨平台应用程序和UI开发框架。
<br><br>
<span style="margin-left:25px"></span>使用Qt只须一次性开发应用程序，无须重新编写源代码，便可跨不同桌面部署这些应用程序。Qt Software的前身为创始于1994年的Trolltech（奇趣科技），Trolltech于2008年6月被Nokia收购，加速了其跨平台开放战略。Qt Creator是支持Qt跨平台开发的Qt IDE，可单独使用，也可以与Qt库和开发工具组成一套的完整的SDK。其中包括：高级C++代码编写器、项目和生成管理工具、集成的上下文相关的帮助系统、图形调试器、代码管理和浏览工具。Qt Creator 具有两个很方便开发的特点：
<br><br>
<span style="margin-left:25px"></span>Qt中UI开发可以直接通过拖拽现有的部件库元件置对应的开发界面上，在通过简单的布局设计就可以快速完成一个美观，快捷的UI界面开发。
<br><br>
<span style="margin-left:25px"></span>信号与槽的机制，可以完成对象之间的协同操作。
<br><br>
<span style="margin-left:25px"></span>简单的说，信号与槽都是函数，比如单机窗口上的一个按钮想要弹出一个对话框，那么就可以将这个按钮的单击 click（）信号与定义的槽函数关联起来，当点击这个按钮时发出 click（）信号，当前界面检测到该按钮的 click（）信号后就会自动调用定义的槽函数来创建一个对话框。这种机制可以快速、方便的将界面的操作和后台执行程序绑定，实现相应的功能。5.2.2上位机软件框架设计
<br><br>
<span style="margin-left:25px"></span>整个上位机的业务需求：
<br><br>
<span style="margin-left:25px"></span>手术开始打开手术管理系统，点击操作界面的登记录入（ COUNT IN）按钮，将手术器械使用前在登记录入处扫描录入，器械使用完后扔进回收桶中。手术结束后点击回收（COUNT OUT）按钮，系统自动统计回收桶中的器械。根据显示结果判断，如果有未回收的遗漏器械，且不在可视范围内，点击扫描（SCAN）按钮用扫描器去病人身体部位探测寻找，快速定位遗漏器械的位置。最后点击详情（DETAIIED）按钮进入详细数据界面保存数据，以便日后查询手术记录查看手术器械使用情况。根据业务需求整个系统的上位机程序框架设计如下图5-3所示：
<br><br>
<span style="margin-left:25px"></span>图5-3上位机程序框架图
<br><br>
<span style="margin-left:25px"></span>5.2.3上位机操作界面的设计
<br><br>
<span style="margin-left:25px"></span>用户UI模块就是系统数据显示与用户交互的界面，采用Qt自带的控件进行拖拽式布局设计，快速完成交互界面的开发。
<br><br>
<span style="margin-left:25px"></span>其中用户的点击按钮采用Qt的button控件结合信号与槽的机制，实现按钮点击后的后台程序触发。系统数据显示采用TableView控件，结合它的视图模型可以简单快速的显示数据库表的数据。UI界面设计图如图5-4所示。图5-4 UI界面设计图
<br><br>
<span style="margin-left:25px"></span>上图中控件通过QLayout类提供的布局管理器，进行了整理布局，使得界面更加整洁美观，界面按水平布局为主，大体分成了三部分。
<br><br>
<span style="margin-left:25px"></span>具体如图5-5所示：图5-5 UI界面分布图
<br><br>
<span style="margin-left:25px"></span>5.2.4后台控制程序的实现
<br><br>
<span style="margin-left:25px"></span>后台控制程序主要分成两个部分：
<br><br>
<span style="margin-left:25px"></span>串口通信程序和数据处理程序。串口通信程序主要功能是负责与系统的阅读器通信，发送指令到阅读器，并接收阅读器返回的数据。
<br><br>
<span style="margin-left:25px"></span>由于系统要确保所接收阅读器数据的安全性和实时性；在安全性方面，采用CRC16校验确保每一帧数据的正确传输（次部分将在下一章节着重介绍）；在实时性方面，采用经典的生产者消费者模型的多线程机制确保串口数据的实时处理。Qt没有现成的串口通信类库调用，借助第三方的串口通信类qextserialport实现，该类分为Win_QextSerialPort和Posix_QextSerialPort分别支持Windows和Linux两种环境。
<br><br>
<span style="margin-left:25px"></span>在项目管理文件.Pro文件中进行如下配置：unix:
<br><br>
<span style="margin-left:25px"></span>DEFINES = _TTY_POSIX_
<br><br>
<span style="margin-left:25px"></span>HEADERS += qextserialport/posix_qextserialport.h
<br><br>
<span style="margin-left:25px"></span>SOURCES += qextserialport/posix_qextserialport.cpp
<br><br>
<span style="margin-left:25px"></span>win32 {
<br><br>
<span style="margin-left:25px"></span>DEFINES = _TTY_WIN_
<br><br>
<span style="margin-left:25px"></span>HEADERS += qextserialport/win_qextserialport.h
<br><br>
<span style="margin-left:25px"></span>SOURCES += qextserialport/win_qextserialport.cpp
<br><br>
<span style="margin-left:25px"></span>然后在 Qt框架下实现串口发送部分比较简单，先获取待发送的字符串，即要发送命名码子，
<br><br>
<span style="margin-left:25px"></span>然后采用 HexStrToByteArray( QString str)函数将字符串转换成十六进制码子，再调用 write()函数将转换后的十六进制码子发送出去，将字符串转换成十六进制码子的 HexStrToByteArray( QString str)函数代码如下：QByteArray HexStrToByteArray(QString str)//字符转十六进制后经串口发送
<br><br>
<span style="margin-left:25px"></span>QByteArray senddata;
<br><br>
<span style="margin-left:25px"></span>//字符转十六进制后暂存在senddata变量中bool ok;
<br><br>
<span style="margin-left:25px"></span> char data; QStringList list;list = str.split(” ”);
<br><br>
<span style="margin-left:25px"></span>//将待转换的字符以空格划分开for(int i = 0;
<br><br>
<span style="margin-left:25px"></span> i [ list.count(); i++){if(list.at(i) == ” ”) continue;
<br><br>
<span style="margin-left:25px"></span>if(list.at(i).isEmpty()) continue;
<br><br>
<span style="margin-left:25px"></span>data = (char)list.at(i).toInt( ok， 16);
<br><br>
<span style="margin-left:25px"></span>//将分割开字符格式化成十六进制if(!
<br><br>
<span style="margin-left:25px"></span>ok){QMessageBox:information(this， tr(”提示”)， tr(”输入数据有误！”)，QMessageBox:
<br><br>
<span style="margin-left:25px"></span>Ok); break;senddata.append(data);
<br><br>
<span style="margin-left:25px"></span>return senddata;
<br><br>
<span style="margin-left:25px"></span>再在主函数中调用该函数将要发送的数据转换化成十六进制的数据，通过串口的write()函数，将数据发送出去，代码如下：
<br><br>
<span style="margin-left:25px"></span>data =assistance:
<br><br>
<span style="margin-left:25px"></span>HexStrToByteArray(writeData);int count = port-]write(data， data.length());
<br><br>
<span style="margin-left:25px"></span>但对于串口接收的部分，相对是比较的复杂。
<br><br>
<span style="margin-left:25px"></span>为了提高程序的工作效率，和该系统中程序的可扩展性，从串口接收到的数据需要经过物理层、缓冲层、校验层、通信协议层和数据处理层，五个层次的处理，才可最终到系统的本地数据库，各个层之间的关系和功能如下图5-6：图5-6 Qt的系统串口接收流程图
<br><br>
<span style="margin-left:25px"></span>对于串口接收数据，因为接收时数据的不均匀流畅，期间存在空白或者间隔，给数据的处理带来很大的难度。
<br><br>
<span style="margin-left:25px"></span>如果直接使用串口的数据接收函数来接收MCU发送的数据，则可能由于以上问题导致接收的数据不完整。因此在具体实现接收数据的时，应该在接收到第一批串口数据后，等待T时间后再接收。如果还有数据则继续接收第二批数据，并加在第一批数据的后面。如此循环，直到在新时间片T结束后没有收到数据，跳出循环。至于T时间片的选择，需要根据具体的模块或者设备来调整，如果时间片T选择过小，则一帧数据会被分割好几个数据帧；如果时间片T选择太大，则可能将两帧数据或者更多的数据帧合并为了一帧数据而接收下来，以上都将造成接收一帧数据不完整或者混乱的现象出现。经过科学的理论分析计算，将 T设置为接收一帧数据中最大时间间隔的1.5倍，既能保证数据的灵敏度，又能保证系统的可靠性，数据接收算法如下图5-7所示。图5-7系统串口超时控制流程图
<br><br>
<span style="margin-left:25px"></span>void ReceiveThread:
<br><br>
<span style="margin-left:25px"></span>run()//启动接收数据的线程{int count=0;
<br><br>
<span style="margin-left:25px"></span>Forever
<br><br>
<span style="margin-left:25px"></span>msleep(3);
<br><br>
<span style="margin-left:25px"></span>mutex.lock();
<br><br>
<span style="margin-left:25px"></span>//加线程锁，确保读取操作的原子性count = comport-]bytesAvailable();
<br><br>
<span style="margin-left:25px"></span>//获取当前可读取的数据长度mutex.unlock();
<br><br>
<span style="margin-left:25px"></span>//线程解锁if (0 [ count)
<br><br>
<span style="margin-left:25px"></span>{lsloop:
<br><br>
<span style="margin-left:25px"></span>msleep(5);//等待5us后if(count[comport-]bytesAvailable())//如果判断串口是否还有数据到来
<br><br>
<span style="margin-left:25px"></span>{count = comport-]bytesAvailable();
<br><br>
<span style="margin-left:25px"></span>//获取可读的字节数goto lsloop;
<br><br>
<span style="margin-left:25px"></span>}//跳转到lsloop等待5us后接着判断emit newDataInPortThread(count);
<br><br>
<span style="margin-left:25px"></span>上面这个在确认串口中一帧数据已完全接收完成后，发射一个信号 newDataInPortThread( count)，
<br><br>
<span style="margin-left:25px"></span>此信号含有此次接收的一帧数据的长度，接收数据的槽函数 newDataInPortSlot( int count)立马读取接收串口接收缓冲区内该长度的数据，即一帧完整的数据。下面的列举的了接收数据的槽函数的示例代码如下：void newDataInPortSlot(int count)
<br><br>
<span style="margin-left:25px"></span>{char data[size];
<br><br>
<span style="margin-left:25px"></span>int readcount = readData(data， count);
<br><br>
<span style="margin-left:25px"></span>//读取该帧数据emit newDataInPortSignal(data，readcount);
<br><br>
<span style="margin-left:25px"></span>在系统中通过信号与槽的机制通过
<br><br>
<span style="margin-left:25px"></span>connect(port，SIGNAL(newDataInPortSignal(const unsigned char *， const int))，this， SLOT(receiveMsg(const unsigned char *， const int)));
<br><br>
<span style="margin-left:25px"></span>将接收完成信号newDataInPortSignal (data，readcount) 与主程序的void MainWindow:
<br><br>
<span style="margin-left:25px"></span>receiveMsg(const unsigned char *data， const int size)槽函数绑定，当检测到newDataInPortSignal（）信号就执行receiveMsg（）函数，从而执行数据处理程序。数据处理程序主要是对接收到的数据进行校验和解析，提取出MCU返回的一些执行动作的读取结果，本系统主要是切换天线和读取各个天线读到的RFID标签的UID。
<br><br>
<span style="margin-left:25px"></span>具体的部分代码可以参考附件。5.3上位机与MCU的通信协议设计
<br><br>
<span style="margin-left:25px"></span>本协议是系统上位机与阅读器中MCU进行通信的协议规范。
<br><br>
<span style="margin-left:25px"></span>在手术器械管理系统中，设计的通信协议要根据 ISO15693协议，实现一些通用的系统的控制命令，负责设置阅读器的工作参数、控制阅读器的射频和输入输出，以及天线切换等。另外还需实现一些普通的ISO15693 标签操作命令集，比如读取标签的UID、数据块外等。整个通信协议是上位机与阅读器之间可靠通信规范约定和保障。通信协议分为请求帧和响应帧两部分。请求帧由通信过程中处于主动地位的设备发出，本系统处于主动地位的是上位机及工控机，两个请求数据帧间隔时间应该不小于50毫秒。
<br><br>
<span style="margin-left:25px"></span>表5-1为请求帧的格式：表5-1请求帧
<br><br>
<span style="margin-left:25px"></span>帧头
<br><br>
<span style="margin-left:25px"></span>帧长
<br><br>
<span style="margin-left:25px"></span>通道地址
<br><br>
<span style="margin-left:25px"></span>命令码
<br><br>
<span style="margin-left:25px"></span>参数
<br><br>
<span style="margin-left:25px"></span>CRC
<br><br>
<span style="margin-left:25px"></span>3bytes
<br><br>
<span style="margin-left:25px"></span>1bytes
<br><br>
<span style="margin-left:25px"></span>1bytes
<br><br>
<span style="margin-left:25px"></span>1bytes
<br><br>
<span style="margin-left:25px"></span>nbytes
<br><br>
<span style="margin-left:25px"></span>2bytes
<br><br>
<span style="margin-left:25px"></span>帧头是指示一帧数据的开始，值为0x112233，用于接收方判别数据的开头。
<br><br>
<span style="margin-left:25px"></span>长度是从通道地址开始到CRC结束，通道地址用于指示不同的天线工作，命令码指示不同的通信目的，保留默认为0x00。参数是命令携带的数据，长度和数据随不同的命令而变。CRC为从帧长度开始到参数区结束的CRC校验码。响应帧由通信过程中处于被动地位的设备响应返回，本系统处于被动地位的是系统阅读器，
<br><br>
<span style="margin-left:25px"></span>响应帧应该会在阅读器收到请求帧数据后的200毫秒内返回。表 5-2 为响应帧的格式。命令码指示不同的通信行为。参数包含执行响应命令后返回的读取数据，因各个命令的不同返回数据不同。表 5-2响应帧
<br><br>
<span style="margin-left:25px"></span>帧头
<br><br>
<span style="margin-left:25px"></span>帧长
<br><br>
<span style="margin-left:25px"></span>通道地址
<br><br>
<span style="margin-left:25px"></span>命令码
<br><br>
<span style="margin-left:25px"></span>参数
<br><br>
<span style="margin-left:25px"></span>CRC
<br><br>
<span style="margin-left:25px"></span>3bytes
<br><br>
<span style="margin-left:25px"></span>1bytes
<br><br>
<span style="margin-left:25px"></span>2bytes
<br><br>
<span style="margin-left:25px"></span>1bytes
<br><br>
<span style="margin-left:25px"></span>nbytes
<br><br>
<span style="margin-left:25px"></span>2bytes
<br><br>
<span style="margin-left:25px"></span>5.4数据库的设计
<br><br>
<span style="margin-left:25px"></span>本系统在上位机中对通过串口接收到的返回数据处理，采用了数据库技术来存储记录读取到的数据，
<br><br>
<span style="margin-left:25px"></span>然后经过一些数据库的条件查询语句来筛选和分类数据，形成业务需求所要得到的手术器械使用结果的信息，然后通过 UI界面中 TableView控件来显示。5.4.1数据库相关技术简介
<br><br>
<span style="margin-left:25px"></span>数据库是一种按照数据结构来组织、存储和管理数据的建立在计算机存储设备上的仓库。
<br><br>
<span style="margin-left:25px"></span>数据库是长期储存在计算机内的有组织的、可共享得数据集合。数据库具有以下特点：
<br><br>
<span style="margin-left:25px"></span>实现数据共享。
<br><br>
<span style="margin-left:25px"></span>所有用户可同时用各种方式通过接口读写数据库，提供数据共享。减少数据的冗余度。
<br><br>
<span style="margin-left:25px"></span>数据库实现数据共享，避免了用户各自建立应用文件，减少了大量的数据重复，维护了数据的一致性。数据的独立性。
<br><br>
<span style="margin-left:25px"></span>数据的独立性是指数据库的逻辑结构和应用程序之间相互独立，互补不影响。数据实现集中控制。
<br><br>
<span style="margin-left:25px"></span>不同的用户或者同一用户在不同的处理中，文件之间是毫不相干的，通过数据模型表示各种数据之间的联系。数据的一致性和可维护性。
<br><br>
<span style="margin-left:25px"></span>防止数据丢失和越权使用，保证数据的正确性和可靠性，可以进行数据的恢复和还原。SQL语句是数据库的通用语言，数据库通过SQL语句来实现方便地查询、定义、操作和控制数据库中的数据。
<br><br>
<span style="margin-left:25px"></span>下面简单的介绍一下本系统中用到的一些语句：SELECT语句
<br><br>
<span style="margin-left:25px"></span>SELECT 列名称 FROM 表名称
<br><br>
<span style="margin-left:25px"></span>INSERT语句
<br><br>
<span style="margin-left:25px"></span>INSERT INTO 表名称 VALUES (值1， 值2，....)
<br><br>
<span style="margin-left:25px"></span>UPDATE语句
<br><br>
<span style="margin-left:25px"></span>UPDATE 表名称 SET 列名称 = 新值 WHERE 列名称 = 某值
<br><br>
<span style="margin-left:25px"></span>DELETE语句
<br><br>
<span style="margin-left:25px"></span>DELETE FROM 表名称 WHERE 列名称 = 值
<br><br>
<span style="margin-left:25px"></span>数据库有很多比如 MySQL、 SQL Server、 Oracle、 SQLite等等，本系统综合考虑后决定使用 SQLite数据，
<br><br>
<span style="margin-left:25px"></span>因为 SQLite代码量特别小，是一个轻量级的数据库系统，处理速度快，占用资源少。考虑手术器械管理系统工控机端的数据处理量基本很小，无需使用大型的数据库系统这样显得很笨重占用资源，另外 SQLite数据库支持跨平台，可以在上位机因系统环境变化时无需多大改动就能使用。5.4.2数据库结构设计
<br><br>
<span style="margin-left:25px"></span>数据库由2张表组成：
<br><br>
<span style="margin-left:25px"></span>Device表。记录所有器械的使用和回收情况；Type表。记录所有器械对应类型的使用和回收情况。Device表与Type表之间具有多对一的关联关系。数据库表关系图如图5-8所示。图5-8数据库表关系图
<br><br>
<span style="margin-left:25px"></span>接收数据的处理流程如下：
<br><br>
<span style="margin-left:25px"></span>手术开始后系统自动创建一张与手术患者有关的Device表。登记天线读取到手术器械内标签的UID，先在表中查询是否已存在此UID记录。如果没有则创建ID为此UID的一条行记录，并将登记天线值写为true，回收天线和扫描天线值写为false，器械类型根据读取到标签的AFI判别。如果存在此UID记录就忽略。回收天线读取到UID，在表中查询是否表中有此UID记录，如果有就将回收天线的值改为true，状态的值也改为true，否则提示该标签未经登记进入使用。扫描天线读取到UID，在表中查询是否表中有此UID记录以及回收天线的值是否为false，如果以上条件都满足就将扫描天线值改为true，否则忽略此UID。手术结束，备份保存数据表以便日后查询手术中器械使用的记录，关闭数据库。Type表每当Device表有数据操作就对其做一次数据统计并更新Type表的内容。
<br><br>
<span style="margin-left:25px"></span>界面根据Type表的内容，统计显示当前各种类型手术器械使用和回收的数量情况。5.4.3系统中有关数据库程序
<br><br>
<span style="margin-left:25px"></span>Qt中的QtSql库提供了对数据的支持，只需在项目的.pro文件中加入：
<br><br>
<span style="margin-left:25px"></span>QT +=sql就可以将库引入，直接使用一些对数据库的连接和语句。其中的QSqlDatabase类用来创建与SQLite数据库的连接通道，QSqlQuery类用来提供SQL语句与数据库的交互；用户接口层的几个类实现了将数据库中的数据链接到窗口部件上。程序中通过createConnection（）函数来实现与数据库通道的连接，代码如下：createConnection()
<br><br>
<span style="margin-left:25px"></span>QSqlDatabase db = QSqlDatabase:
<br><br>
<span style="margin-left:25px"></span>addDatabase(”QSQLITE”);//创建sqlite数据库db.setDatabaseName(”record.db”);//创建的sqlite数据库命名为record.dbif (!
<br><br>
<span style="margin-left:25px"></span>db.open())//打开数据库{QMessageBox:
<br><br>
<span style="margin-left:25px"></span>critical(0， ”open db fail”，”connect fail”， QMessageBox:Cancel);return false;
<br><br>
<span style="margin-left:25px"></span>QSqlQuery query;
<br><br>
<span style="margin-left:25px"></span>// 创建表单query.exec(QString(”create table Device(id varchar primary key， ”
<br><br>
<span style="margin-left:25px"></span>”R1 varchar，R2 varchar，R3 varchar，state varchar，type varchar)”));
<br><br>
<span style="margin-left:25px"></span>return true;
<br><br>
<span style="margin-left:25px"></span>另外在程序后续的数据处理中通过使用一些query语句来对数据库表中的数据进行怎、删、改、查，实现业务对数据的要求，例如以下几句query语句：
<br><br>
<span style="margin-left:25px"></span>query.exec(QString(”select type from Device where type = ’%1’”).arg(type));
<br><br>
<span style="margin-left:25px"></span>//到Device表中查询是否已存储此类型
<br><br>
<span style="margin-left:25px"></span>query.prepare(”insert into Device (type，R1，R2，R3，R4) values(:
<br><br>
<span style="margin-left:25px"></span>type，:R1，:R2，:R3，:R4)”);//将读取的数据插入到Device
<br><br>
<span style="margin-left:25px"></span>表中query.exec(QString(”update Typeset state = ’yes’ where id = ’%1’”).arg(sqlTmp));
<br><br>
<span style="margin-left:25px"></span>//更新Type表中的一些类型的数据。
<br><br>
<span style="margin-left:25px"></span>因为数据处理相对复杂涉及到很多语句和query语句，这里就不一一介绍。
<br><br>
<span style="margin-left:25px"></span>5.5本章小结
<br><br>
<span style="margin-left:25px"></span>本章详细的分析介绍了手术器械管理系统的软件部分的设计。
<br><br>
<span style="margin-left:25px"></span>第一节介绍了阅读器端MCU上的控制程序设计，介绍了整个MCU程序的大体结构和分析重要部分的代码实现过程；第二节介绍了工控机端的基于 Qt技术的上位机程序开发过程，先从整体结构设计开始介绍，再介绍了 Qt中本系统的 UI界面开发细节，然后结合流程图分析了一些重要环节的代码实现和原理。第三节介绍了阅读器端的MCU和上位机之间的通信协议规范。第四节单独介绍了本系统在上位机程序中涉及到的数据库知识和应用，使得读者更加清楚本系统对数据的处理方法。总体上本章详细地分析了手术器械管理系统的软件设计过程和原理，使得读者能够很好的了解系统的软件部分。第六章系统可靠性的研究与改进
<br><br>
<span style="margin-left:25px"></span>手术器械管理系统从需求开始就是一个对安全可靠性要求很高的手术辅助器械，不允许系统的任何意外漏读出现（除人为操作失误外），否则后果不堪设想。
<br><br>
<span style="margin-left:25px"></span>本系统在整体系统设计完成之后，根据理论分析和实际测量结果，对系统做了相应的可靠性分析和改进，确保系统的安全可靠。6.1系统的可靠性分析与改进
<br><br>
<span style="margin-left:25px"></span>从系统的整体设计结构上来分析，可靠性需要得到保证的环节主要分为两个：
<br><br>
<span style="margin-left:25px"></span>系统在读取RFID标签时的绝对无误和系统在数据传递时的完整无误。手术器械管理系统在登记录入天线和扫描天线读取数据时同时读取的标签数有限不会很多，
<br><br>
<span style="margin-left:25px"></span>在目前的抗冲突读取中基本不会出现漏读的情况，即使这样本系统也做了防护措施，采用多次读取的方法，防止任何一次遗漏读取。在回收桶天线读取时难度比较大，因为手术器械用完后随手扔在桶中器械内嵌的 RFID标签朝向各个方向都有，同时桶内的标签数也会比较多，这样的读取环境很容易造成遗漏，为此专门设计了读取算法来避免漏读。数据通信发生在RFID标签到系统的阅读器和阅读器到上位机程序，只要任何一个环节出了问题，数据都会出现错误，是一种串联的关系，一断则断。因此在通信中都采用CRC校验的方法，来确保每次通信数据的正确性。6.2系统在数据通信上的可靠性保障
<br><br>
<span style="margin-left:25px"></span>在以前的通信应用中，由于技术的限制，和通信中信道的复杂多变，严重干扰了信号在信道里的传输，很容易就出现误码，导致信息的不可靠。
<br><br>
<span style="margin-left:25px"></span>为了保证数据通信上的可靠性，就需要通过校验数据来判别信息的正确性。循环冗余校验就是目前串口通信中最常用的方法。它从通信中信息的本身来校验，采用数学的运算办法对信息进行分析处理。如果运算后结果正确就保留，如果运算结果不正确就丢弃或者修复该信息。循环冗余校验，先将数据转化为多项式，然后对多项式进行计算，将得到的结果附加在信息之后。
<br><br>
<span style="margin-left:25px"></span>接收到该信息的设备，采用同样的CRC校验，从而确保接收信息的完整性和无误性。CRC信息码有信息码（n个比特）和校验码（k个比特）组成，写成（n，k）码。编码规则是先将信息码左移r位，再对生产多项式模二除，计算得到的余数就是CRC的校验码。对于任意通信码字，有且仅有一个R次多项式g（x），其计算的数学表达式如式子6-1：(6-1)
<br><br>
<span style="margin-left:25px"></span>其中m(x)是信息多项式，r(x)是校验多项式，g(x)是生成多项式如式子6-2：
<br><br>
<span style="margin-left:25px"></span>(6-2)
<br><br>
<span style="margin-left:25px"></span>信源通过生成多项式产生CRC校验码，信宿则利用生成多项式来验证接收的信息。
<br><br>
<span style="margin-left:25px"></span>循环冗余校验根据权的不同，其生成多项式有CRC8、CRC12、CRC16、CRC32等。本项目采用的是CRC16其生成多项式如式子6-3：(6-3)
<br><br>
<span style="margin-left:25px"></span>下面详细分析任意长度数据流的CRC16校验码生成的过程。
<br><br>
<span style="margin-left:25px"></span>智能纱布系统所采集的数据流被分成若干个8bit字符，并且是从低字节到高字节发送方式来计算CRC 校验码。图6-1CRC校验图
<br><br>
<span style="margin-left:25px"></span>具体生成校验码的过程是，用一个十六位的寄存器来存放信息码字，寄存器的初值是0x0000；
<br><br>
<span style="margin-left:25px"></span>先将信息的低位八比特和寄存器的高八位相异或，结果就保存在寄存器的高八位中；然后寄存器左移一位。左移后低位补零，如果移出的高位是零，就继续左移，直到移出为是一；之后把生成多项式和寄存器异或，结果还是保存在寄存器中；重复上述过程直到处理完成十六位数据。完成上面的计算后，寄存器中的数据就是该信息码的CRC校验码。上图6-1展示了CRC计算流程。在手术器械管理系统的上位机中，串口接收的每一帧数据都将经过 calc_ crc()函数校验，该函数需要两个参数，
<br><br>
<span style="margin-left:25px"></span>这两个参数正是上一章节串口程序中讲到的 newDataInPortSignal( data， readcount)信号发射后传递的两个参数；第一个参数用来指示等待校验数据的长度，第二个参数是一个指向存储等待校验数据的首地址，其实现代码如下：int calc_crc(unsigned int byte_len， unsigned int *data_byte)
<br><br>
<span style="margin-left:25px"></span>{unsigned int current_crc_value;
<br><br>
<span style="margin-left:25px"></span>unsigned int i，j;
<br><br>
<span style="margin-left:25px"></span>current_crc_value=0xFFFF;
<br><br>
<span style="margin-left:25px"></span>for(i=0;
<br><br>
<span style="margin-left:25px"></span>i[byte_len;i++){current_crc_value=current_crc_value^data_byte[i];
<br><br>
<span style="margin-left:25px"></span>for(j=0;
<br><br>
<span style="margin-left:25px"></span>j[8;j++){if(current_crc_value 0x0001)
<br><br>
<span style="margin-left:25px"></span>{current_crc_value=(current_crc_value]]1)^0x8408;
<br><br>
<span style="margin-left:25px"></span>else{
<br><br>
<span style="margin-left:25px"></span>current_crc_value=(current_crc_value]]1);
<br><br>
<span style="margin-left:25px"></span>}}current_crc_value = ~current_crc_value;
<br><br>
<span style="margin-left:25px"></span>return(current_crc_value 0xFFFF);
<br><br>
<span style="margin-left:25px"></span>只有在经过CRC校验后，并且结果正确，程序才将该帧数据接着传入到下一层，就是上面提到的环形缓冲层。
<br><br>
<span style="margin-left:25px"></span>在MCU程序中采用字节查表法来进行CRC校验，在MCU硬件端可以大大提高计算速度。
<br><br>
<span style="margin-left:25px"></span>程序如下：u16 table_crc(u8 *ptr，u16 len) // 字节查表法求 CRC
<br><br>
<span style="margin-left:25px"></span>u16 crc=0xffff;
<br><br>
<span style="margin-left:25px"></span>while(len--)
<br><br>
<span style="margin-left:25px"></span>crc= (crc ]] 8) ^ crc_ta((crc ^ *ptr) 0xff);
<br><br>
<span style="margin-left:25px"></span> //FLASHptr ++;
<br><br>
<span style="margin-left:25px"></span>return(~crc);
<br><br>
<span style="margin-left:25px"></span> // CRC校验码取反crc_ta是先前算好的CRC16的256个余式表数组，存放在flash内存中。
<br><br>
<span style="margin-left:25px"></span>通过uint table_crc(uchar *ptr，uchar len)函数来快速计算CRC，输入: uchar *ptr: 数据；uchar len : 数据长度。输出: CRC16码。通过以上2次的CRC校验，确保了在数据传递的环节中不会出现错误数据，杜绝了因数据传递出错了而引起的问题，做到有传递就有校验。
<br><br>
<span style="margin-left:25px"></span>6.3系统在数据读取上的可靠性保障
<br><br>
<span style="margin-left:25px"></span>手术器械管理系统在登记录入天线和扫描天线读取数据时采用多次读取的方法，防止任何一次遗漏读取。
<br><br>
<span style="margin-left:25px"></span>当一次的漏读的概率为0.5%时，当执行5次读取时，漏读的概率为0.5%*0.5%*0.5%*0.5%*0.5%=0.03125%，如果读取10次的话漏读的概率为0.0009765625%，按此推断，次数越多，发生漏读的概率越低。但由于不可能一直读下去，本系统设计成，当执行某个天线读取时，在没有执行其他的命令前，会一直循环做读取操作，并在程序中做校验，判断是否已经读到目前读取的数据，如果没有就添加。这样防止因一次漏读二造成的遗漏。回收桶天线读取在已有的15693抗冲突算法的基础上，采用的改进的防冲突算法，提高回收桶中标签的抗冲突效率。
<br><br>
<span style="margin-left:25px"></span>回收桶的三组天线不是同时上电工作的，同时工作会产生相互干扰。它们是按照一定顺序依次工作，每一组线圈天线分别覆盖桶内一定的区域。考虑到从天线1切换到天线2的时候有个掉电的瞬间，导致桶内所以的标签重新进入了磁场，重新激活，不管刚才天线1是否读取过该标签，都要重新再参与一次抗冲突。这势必降低增加系统抗冲突的负担，降低识别率，延长识别的时间。由上面的问题，提出了一种适用于该回收桶的，标签抗冲突算法。就是先静默再做抗冲突的算法，具体的构想是，对每次读到的标签UID做一定的运算，重排及剔除重复标签的操作，然后静默重排后的标签，再做抗冲突，发现新的标签。图6-2回收桶内的天线设计
<br><br>
<span style="margin-left:25px"></span>回收桶内天线线圈的分布如上图6-2所示，先让纱布桶的天线1工作，
<br><br>
<span style="margin-left:25px"></span>对其区域的标签做一次抗冲突，把读取的标签 UID全部暂时存储在一个 UID缓冲池里面；然后切换到天线2，发一遍静默命令，将池中已有的UID都静默后，再让天线2做抗冲突，将此次读取到的UID存于池内，同时重排剔除重复的UID；之后切换到天线3，同样静默缓冲池中的UID后，在让天线3做抗冲突获取标签信息，最后将汇总的标签UID通过串口传送到上位机。为了确保所有在纱布桶中的标签都读到，在上述的基础上，也采用了多次读取的方法，就是在重复读取的时候，先清空UID池，在重复上面的抗冲突流程。下图6-3展示了回收桶内标签的抗冲突流程。图6-3回收桶内抗冲突流程图
<br><br>
<span style="margin-left:25px"></span>6.4系统的实物和运行界面展示
<br><br>
<span style="margin-left:25px"></span>为了验证系统的准确性和可靠性，选取了8张 ISO15693协议的射频标签，
<br><br>
<span style="margin-left:25px"></span>分别放置在40*40纱布、100*60纱布、100*100纱布和手术剪刀四种器械中，并将这8张标签的 AFI写成对应型号的编码。然后模拟手术过程使用手术器械。手术操作流程如下：
<br><br>
<span style="margin-left:25px"></span>手术开始打开手术管理系统，点击操作界面的登记录入（ COUNT IN）按钮，将手术器械使用前在登记录入处扫描录入，器械使用完后扔进回收桶中。手术结束后点击回收（COUNT OUT）按钮，系统自动统计回收桶中的器械。根据显示结果判断，如果有未回收的遗漏器械，且不在可视范围内，点击扫描（SCAN）按钮用扫描器去病人身体部位探测寻找，快速定位遗漏器械的位置。最后点击详情（DETAIIED）按钮进入详细数据界面保存数据，以便日后查询手术记录查看手术器械使用情况。实验过程中故意让1块100*60型号和1块100*100型号的纱布未放进回收桶模拟遗漏的情况，
<br><br>
<span style="margin-left:25px"></span>系统能够准确的显示这2种纱布各有1块未回收，实验结果如图6-4所示。然后用扫描器找到这2块纱布后，系统显示没有手术器械遗漏。图6-4实验结果界面
<br><br>
<span style="margin-left:25px"></span>实验证明登记和回收的天线能够迅速没有遗漏地读取多个手术器械，扫描器的天线能够快速准确地探测到遗漏的器械。
<br><br>
<span style="margin-left:25px"></span>长时间工作，系统运行稳定，响应迅速。整个系统实物图如图6-5所示。图6-5系统实物
<br><br>
<span style="margin-left:25px"></span>6.5本章小结
<br><br>
<span style="margin-left:25px"></span>本章介绍了手术器械管理系统的可靠性分析和改进，先从整体上分析了需要改进的地方，以及改进的方法，然后分别从数据读取和数据传递的两个部分进行了理论分析和改进说明。
<br><br>
<span style="margin-left:25px"></span>本章所做的工作对于本系统属于画龙点睛之笔，只有有了可靠性，手术器械管理系统才具有实际的使用价值。第七章结论与展望
<br><br>
<span style="margin-left:25px"></span>7.1结论
<br><br>
<span style="margin-left:25px"></span>本文针对手术异物遗留的难题，结合ISO15693协议的RFID芯片，自主设计了一种RFID手术器械管理系统。
<br><br>
<span style="margin-left:25px"></span>该系统与之前手术器械管理方法相比：可以大大降低手术中手术器械清点者的压力和工作量，准确、稳定的显示手术器械的使用和回收情况，确保手术器械无遗漏，为手术安全提供最后一道防线。本文在深刻学习射频识别技术的理论基础上，结合手术室内手术器械使用的实际情况，对内嵌有RFID标签的手术器械进行规范、高效、安全可靠的系统的设计。本文具体的工作内容如下：1) 首先从整个系统的业务需求入手结合事先掌握的射频识别技术的理论知识设计了手术器械管理系统的整体框架。
<br><br>
<span style="margin-left:25px"></span>再根据框架中涉及的理论知识和原理进行学习和掌握。2) 完成了系统硬件电路中FPGA编解码电路、MCU电路设计和FPGA与MCU两个模块之间的接口设计。
<br><br>
<span style="margin-left:25px"></span>针对不同模块之间时序同步问题设计了通过单片机外部中断模仿SPI通信方式的方法来传递数据。基本完成了系统硬件部分对RFID标签读取的功能。3) 开发了基于STC单片的C语言程序开发，完成了整个硬件电路的控制功能。
<br><br>
<span style="margin-left:25px"></span>基于 Qt开发了系统的器械管理操作界面及系统的上位机程序，通过串口与 STC单片机相连，传递数据和操作命令，将读取的数据存放在 QSlite数据库中并进行相应需求的处理后通过 UI界面进行显示。4)最后对手术器械管理系统的实际使用和测试后，分析系统的可靠性和需要改进的部分，
<br><br>
<span style="margin-left:25px"></span>进行了系统相应的提升和优化，有效的防止了手术器械的读取遗漏和数据传递校验。总体上达到了起初的设计需求。7.2展望
<br><br>
<span style="margin-left:25px"></span>本文紧密围绕手术器械管理系统的应用设计，积极开张了相关的研究工作，
<br><br>
<span style="margin-left:25px"></span>取得了一定的研究成果，本人也在改项目中深入学习了射频识别技术、 FPGA硬件电路开发、 MCU应用开发和基于 Qt技术的 UI应用程序开发等知识，但仍然感觉到一些该系统还有很多可以扩展和有待改善的地方，值得更加深入的去学习和提高。主要在于：1)上位机上运行的手术器械信息数据的管理软件功能相对比较简单，实现了一些基本数据存储、备份和查表的功能，
<br><br>
<span style="margin-left:25px"></span>而当对数据做复杂的运算和生成报表功能时就具有一定的局限性。2) 本系统使用的工控机因考虑到开发成本，选用了一些性能并不是很好的，价格相对比较低的品牌。
<br><br>
<span style="margin-left:25px"></span>但如果为了整个系统在控制上的稳定和可靠，可以考虑更换更加专业标准的工控机代替。3) 对于该系统可以通过网络的扩展连接到医院的服务器上，将手术器械的使用情况上传至服务器，为智能化医院提供支持。
<br><br>
<span style="margin-left:25px"></span>比如：和医院的手术器械的库存量进行数据处理，可以得到当前医院手术器械可用的量，有利于医院对手术器械的库存管理。总之该系统可以作为手术室内的一个终端为医院大数据服务提供数据源采集。致谢
<br><br>
<span style="margin-left:25px"></span>时光匆匆，毕业转眼就到了。
<br><br>
<span style="margin-left:25px"></span>在此，提笔感谢那些在研究生期间给与过我帮助的需要感谢的人。首先，我要感谢这三年中专用集成电路重点实验室各位老师给予了我指导，正是有了您们的帮助和指导让我在这段学习生活中找到了正确的前进方向，
<br><br>
<span style="margin-left:25px"></span>在知识方面能够保持深入的学习，不断地成长。另外，我要特别感谢我的研究生导师景为平老师，感谢景老师在我学习和生活中的帮助和指导，您严瑾的科研态度，渊博的专业知识给我留下了深刻的印象，不仅让我学到了够硬的专业知识，更让我学到了处理问题的方法和态度，这将是我人生中的重要收获。另外，我还要感谢计算机系的陈晓勇老师，在软件学习和开发中帮助我解决问题，使得我可以更加快速的完成本文系统UI程序的开发。
<br><br>
<span style="margin-left:25px"></span>感谢所有14级电子学院的研究生同学们，与我一起学习、科研生活。感谢我的师兄沈伯洵、龙硕、周蒙蒙、张慧雷和钱一文在我整个系统开发中的帮助和指导。感谢都平和范巍同学三年学习生活中的陪伴，和你们一起在景老师门下学习的经历我终身难忘，愿这份情谊长存。最后，感谢我的父母对我的支持和关心，让我可以专心的投入到学习中，感谢我的妻子和儿子，在我遇到困难和挫折的时候你们是我的精神支柱，我爱你们！
<br><br>
<span style="margin-left:25px"></span>

<br>
<div style="margin-left:8px">

<div style="text-align:center;background-color:#CA122C;margin-top:30px;overflow:hidden;">
<a href="http://www.paperpass.com/publish/index?from=ppreport_banner" target="_blank" style="display:block;"><img height="180" src="http://file.paperpass.com/images/fabiao.jpg"></a>
</div>

</div>
</div>


<div class="zhengwencenter">
<p>
检测报告由<a href="http://www.paperpass.com/" target="_blank">PaperPass</a>文献相似度检测系统生成
</p>
<p>
Copyright © 2007-2017 PaperPass
</p>
</div>
<div style="margin-bottom:400px"></div>
</body>
</html>
